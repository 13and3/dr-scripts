
unless HAVE_GTK
  respond
  respond 'error: ruby-gtk bindings are not installed or failed to load'
  respond
  exit
end

custom_require('drinfomon')

status_tags

class GameFilter
  attr_accessor :seen_lines

  def initialize
    @settings = get_settings(['filters'])
    if File.exist?('seen_messages.dat')
      @seen_lines = Marshal.load(File.open('seen_messages.dat', 'rb'))
    else
      @seen_lines = {}
    end
    @room_players = []
    @monster_nouns = %w(beisswurm)
    @filter_strings = @settings['filter_strings'].map { |string| /#{string}/ }
    @non_useful_tags = [
      /\<preset id='roomDesc'\>/i,
      /pushStream id="atmospherics"/i,
      /pushStream id="thoughts"/i,
      /pushStream id="talk"/i,
      /pushStream id="death"/i,
      /pushStream id="group"/i,
      /pushStream id="percWindow"/i,
      /component id='room/i,
      /component id='exp/i,
      /\<\/prompt\>$/,
      /preset id='roomDesc'/,
      /style id="roomName"/,
      /\<spell exist='spell'\>/,
      /\<spell\>None\<\/spell\>/,
      /&lt; .*/,
      /\<clearContainer/,
      /\<right/,
      /\<left/,
      /\<indicator id='IconINVISIBLE'/,
      /\<roundTime value='\d+'\/\>/
    ]
    @responses = ["'Hmmm?", "'Yes", "'Ok?"]
    @recent_seen = []

    @spam_filtered = [
      /^You feel confident you are heading/,
      /^(Obvious|Blazed) \w+:/,
      /^  a /,
      /^  some /,
      /^  an /,
      /^You are already as far away/,
      /^\w+ just arrived/,
      /^\[.*\]/,
    ]
  end

  def clean_seen_with_filters
    @seen_lines.delete_if { |line, _| @filter_strings.find { |regex| line =~ regex } }
  end

  def save
    base = {}
    if File.exist?('seen_messages.dat')
      base = Marshal.load(File.open('seen_messages.dat', 'rb'))
    end
    @seen_lines.merge!(base)
    clean_seen_with_filters
    File.open('seen_messages.dat', 'wb') { |file| Marshal.dump(@seen_lines, file) }
  end

  def unseen?(line)
    return nil if line.nil? || line.empty?
    return nil if @filter_strings.find { |regex| line =~ regex }
    return nil if @seen_lines[line]
    @seen_lines[line] = true
  end

  def find_pcs(room_players)
    room_players.sub(/ and (.*)$/) { ", #{Regexp.last_match(1)}" }
      .split(', ')
      .map { |obj| obj.sub(/ who is .+/, '').sub(/ \(.+\)/, '') }
      .map { |obj| obj.strip.scan(/\w+$/).first }
  end

  def update_players(line)
    if line =~ /\'room players\'\>Also here: (.*)\.\<\/component\>/
      @room_players = find_pcs(Regexp.last_match(1).dup)
    elsif line =~ /\'room players\'\>\<\/component\>/
      @room_players = []
    end
  end

  def spam_check(line)
    return if line.length < 20 or @spam_filtered.find { |spam| spam =~ line }
    @recent_seen << line
    @recent_seen = @recent_seen[1..10] if @recent_seen.length > 10
    counts = @recent_seen.each_with_object(Hash.new(0)) { |phrase, count| count[phrase] += 1 }
    if counts.values.max >= 5
      echo("\a")
      pause 0.25
      echo("\a")
      pause 0.25
      echo("\a")
      pause 0.25
      fput @responses.first
      echo "#{line}"
      echo "#{counts}"
      @responses.shift
      pause 10
      @recent_seen = []
    end
  end

  def clean(line)
    update_players(line)
    return nil if line.nil? || line.empty? || @non_useful_tags.find { |bad_tag| bad_tag =~ line } || @room_players.find { |name| line.include?(name) } || @monster_nouns.find { |name| line.include?(name) }
    line.gsub!(/\<[^\>]+\>/, '')
    spam_check(line) unless line.empty?
    line
  end
end

def update_health_bar(entry)
  hp = checkhealth
  if hp >= 75
    entry.modify_base(Gtk::STATE_NORMAL, Gdk::Color.parse('green'))
  else
    entry.modify_base(Gtk::STATE_NORMAL, Gdk::Color.parse('red'))
  end
  entry.text = "#{hp}%"
end

filter = GameFilter.new
window = nil
window_done = false
load_window_position = CharSettings['window_position'] || []
load_window_width    = CharSettings['window_width'] || 300
load_window_height   = CharSettings['window_height'] || 100
window_title = "#{checkname} Status"
save_window_position = nil
save_window_width    = nil
save_window_height   = nil
sort_ascending = true
healthbar_et = nil
messages_tv = nil

before_dying do
  CharSettings['window_position'] = save_window_position if (save_window_position.class == Array) && (save_window_position[0].to_i >= 0) && (save_window_position[1].to_i >= 0)
  CharSettings['window_width']    = save_window_width    if (save_window_width.class == Fixnum) && (save_window_width > 100)
  CharSettings['window_height']   = save_window_height   if (save_window_height.class == Fixnum) && (save_window_height > 100)
  Gtk.queue { window.destroy }
  filter.save
end

begin
  Gtk.queue do
    messages_tv = Gtk::TextView.new
    messages_tv.editable = false
    messages_tv.cursor_visible = false

    messages_sw = Gtk::ScrolledWindow.new
    messages_sw.add(messages_tv)
    messages_sw.set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC)

    healthbar_et = Gtk::Entry.new
    healthbar_et.editable = false
    healthbar_et.xalign = 0.5
    health_font = Pango::FontDescription.new
    health_font.weight = Pango::FontDescription::WEIGHT_BOLD
    healthbar_et.modify_font(health_font)

    vbox = Gtk::VBox.new
    vbox.pack_start(messages_sw)
    vbox.pack_start(healthbar_et, false)

    window              = Gtk::Window.new
    window.title        = window_title
    window.keep_above = true
    window.border_width = 1
    window.resize(load_window_width, load_window_height)
    unless load_window_position.empty?
      window.move(load_window_position[0], load_window_position[1])
    end
    window.add(vbox)

    window.signal_connect('delete_event') do
      save_window_position = window.position
      save_window_width    = window.allocation.width
      save_window_height   = window.allocation.height
      window_done = true
    end
    window.show_all
  end
  prev_health = 0

  loop do
    line = script.gets?
    back = line.dup if variable.include?('debug')
    if prev_health != checkhealth
      prev_health = checkhealth
      Gtk.queue { update_health_bar(healthbar_et) }
    end
    if filter.unseen?(filter.clean(line))
      open("status-monitor-debug-#{checkname}.txt", 'a') { |f| f.puts(back); f.puts(line) } if variable.include?('debug')
      Gtk.queue do
        text_buffer = messages_tv.buffer
        text_buffer.insert(text_buffer.end_iter, line)
        text_buffer.insert(text_buffer.end_iter, "\r\n")
        messages_tv.scroll_to_iter(text_buffer.end_iter, 0.0, true, 0, 0)
      end
    else
      pause 0.1 unless back
    end
    break if window_done
  end
end

#quiet
=begin
    Suggestions and contributions are welcome: https://github.com/rpherbig/dr-scripts

    A large set of helper functions for common actions shared by many scripts
=end

# TODO: bput does not have a homogeneous return type. Should it be changed? Split into two methods?

# TODO: Maybe do this: https://github.com/Zeumo/ruby-style-guide#flat-map ?

# TODO: Fix oxford commas issues better.

if $SAFE > 0
  echo "WARNING: This script may not work if not trusted and other scripts that rely on this one may not work. (;trust #{script.name.downcase})"
end

$FAILED_COMMAND = "*FAILED*"

# blocking put
# bput is designed to be a more robust version of fput in situations where you know the desired response from the game
# unlike fput which will resend the same command repeatedly until it sees the desired message first from the game, bput only
# sends a given command one time (unless round time or type ahead errors occur) and then waits for the desired response.
# if the desired response isn't seen bput will eventually time out and echo debugging information.

# fput "forage grass", 'Roundtime' < This would never work because the game sends a response line "You search around..." before "Roundtime" is encountered.

# Similarly a command that can only succeed once can cause fput to hang.
# fput "get box", 'you pick up', 'get what?' < You have to deal with the failure case and just spam
# the command until failure in a noisy room with fput.
# bput "get box", 'you pick up', 'get what?' < lets you know with confidence if a box was picked up or if the item was missing.

# advanced features: Group capturing
# This will most likely be made into a separate method later, but for now you can supply bput with capture groups in your regex and it will return
# the match array for that.
# echo bput("look in bag", 'In the (.*) you see (.*)\.')
# > ["In the green bag you see an apple, some skeleton-shaped taffy and a spun sugar whistle.",
#    "green bag",
#    "an apple, some skeleton-shaped taffy and a spun sugar whistle"]

def bput(message, *matches)
    timer = Time.now
    log = []
    matches.flatten!
    matches.map!{|item| item.kind_of?(Regexp) ? item : /#{item}/i}
    clear
    put message
    while (Time.now - timer < 15)
        clear.each do |response|
            log += [response]

            case response
            when /(?:\.\.\.wait |Wait )([0-9]+)/
                pause $1.to_i
                put message
                timer = Time.now
                break
            when /Sorry, you may only type ahead/
                pause 1
                put message
                timer = Time.now
                break
            when /^You are a bit too busy performing to do that/
                put "stop play"
                put message
                timer = Time.now
                break
            end

            matches.each do |match|
                if (result = response.match(match))
                    return result.to_a.length == 1 ? result.to_a.first : result.to_a
                end
            end
        end
        pause 0.25
    end
    echo '*** No match was found after 15 seconds, dumping info'
    echo "messages seen: #{log}"
    echo "checked against #{matches}"
    $FAILED_COMMAND
end

def remove_armor(armors)
    armors.each do |piece|
        fput "remove my #{piece}"
        fput "stow my #{piece}"
        pause 0.25
    end
end

def wear_armor(armors)
    armors.each do |piece|
        fput "get my #{piece}"
        fput "wear my #{piece}"
        pause 0.25
    end
end

def forage(item)
    if checkright.nil?
        while checkright.nil?
            bput("forage #{item}", 'Roundtime')
            waitrt?
        end
    elsif checkleft.nil?
        while checkleft.nil?
            bput("forage #{item}", 'Roundtime')
            waitrt?
        end
    else
        echo "Don't call forage without an empty hand!"
    end
end

def hand_over(items, person)
    items.each do |item|
        fput("get my #{item}")
        bput("give #{item} to #{person}", '^You offer your .* to')
        waitfor('has accepted your offer')
    end
end

def get_boxes(container)
    result = bput("rummage /B my #{container}", 'but there is nothing in there like that\.', 'looking for boxes and see .*')
    return [] if result == 'but there is nothing in there like that.'

    boxes_text = extract_rummage_text(result)

    list_to_nouns(boxes_text)
end

def extract_rummage_text(raw)
    raw.match(/looking for .* and see (.*)\.$/).to_a[1]
end

#Take a game formatted list "an arrow, silver coins and a deobar strongbox"
#And return an array ["an arrow", "silver coins", "a deobar strongbox"]
#is this ever useful compared to the list_to_nouns?
def list_to_array(list)
    list.strip.split(/,|\sand\s/)
end

#Take a game formatted list "an arrow, silver coins and a deobar strongbox"
#And return an array of nouns ["arrow", "coins", "strongbox"]
def list_to_nouns(list)
    list_to_array(list)
        .map{|long_name| get_noun(long_name) }
        .compact
        .select{|noun| noun != "" }
end

def get_noun(long_name)
    long_name.strip.scan(/[a-z\-]+$/i).first
end

def empty_hands
    while checkright != nil
        fput "stow right"
    end

    while checkleft != nil
        fput "stow left"
    end
end

def walk_to(room_num)
    return if room_num.to_i == Room.current.id.to_i
    fput "retreat" if DRRoom.npcs.count > 0
    fput "retreat" if DRRoom.npcs.count > 0

    start_script "go2", ["#{room_num}"]
    timer = Time.now
    while running?("go2")
        if (Time.now - timer) > 30
            kill_script "go2"
            timer = Time.now
            start_script "go2", ["#{room_num}"]
        end
        pause 0.5
    end

    #Consider just returning this boolean and letting callers decide what to do on a failed move.
    if room_num.to_i != Room.current.id.to_i
        echo "Failed to navigate to room #{room_num}, attempting again"
        walk_to room_num
    end
end

class Item
    @name
    @is_leather
    @is_worn

    def initialize(name:nil, leather:nil, worn:nil)
        @name = name
        @is_leather = leather
        @is_worn = worn
    end

    def is_leather?
        return @is_leather
    end

    def is_worn?
        return @is_worn
    end

    def name
        return @name
    end
end

#windows only I believe.
def beep
    echo("\a")
end

def dispose_trash(item)
    trashcan = DRRoom.room_objs
        .map{|long_name| get_noun(long_name) }
        .select{|obj| UserVars.trash_storage.include?(obj)}
        .first
    trashcan = 'bucket' if trashcan == 'gloop'
    if trashcan
        bput("put my #{item} in #{trashcan}", '^You drop')
    else
        fput "drop my #{item}"
    end
end

def bind_wound(part)
    waitrt?
    case bput("tend my #{part}", 'You work carefully at tending your wound', '') #Are there other messages?
    when $FAILED_COMMAND
        pause 5
        bind_wound(part)
    end
    waitrt?
end

def unwrap_wound(part)
    waitrt?
    case bput("unwrap my #{part}", 'You unwrap your bandages') #Are there other messages?
    when $FAILED_COMMAND
        pause 5
        bind_wound(part)
    end
    waitrt?
end

UserVars.loot_nouns = %w(nugget tsavorite zircon quartz chalcedony diopside coral moonstone onyx topaz amber pearl chryso
    lazuli turquoise bloodstone hematite morganite sapphire agate bar carnelian diamond crystal emerald
    ruby tourmaline tanzanite jade ivory sunstone iolite beryl garnet alexandrite amethyst citrine
    aquamarine star-stone crystal kunzite stones spinel opal peridot, andalusite)

UserVars.trash_nouns = %w(leaf pestle mortar label runestone flower arrowhead root stem grass needle sap glue)

UserVars.trash_storage = %w(bin gloop barrel bucket)

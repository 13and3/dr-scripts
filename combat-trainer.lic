=begin
    Authored by Sheltim and Seped. Suggestions and contributions are welcome: https://github.com/rpherbig/dr-scripts

    This script will be used by combat-trainer-setup to train a list of skills in order of the lowest amount of field experience.

    Before running this script for the first time:
    * Download scripts "common", "drinfomon", "events", and "spellmonitor".

    * Download "combat-trainer-setup" configure it for your use, and run it.
=end

# TODO: when no enemies in the room don't pause. Instead collect once and kick pile to train perc/outdoors.

# TODO: Handle the case in which two defenses are soft/hard capped. It currently keeps 100/80 those two since they are not gaining field exp, which leaves my third defense unused (and thus it will always be behind the other two).
# Is this fixed now that there is a secondary sort on rank?

# TODO: Convert "combat-trainer" to "combat-trainer-engine" and "combat-trainer-setup" to "combat-trainer". This means what was the setup script will now be the script you run. It would manage combat_vars, dependencies, etc. and feed those to the engine script.

class SetupProcess
  include DRC

  def initialize(dance_threshold:0, dance_skill:nil, stances:[], weapon_training:{}, worn_weapons:{})
    echo("SetupProcess(#{dance_threshold},#{dance_skill}, #{stances}, #{weapon_training}, #{worn_weapons})") if $debug_mode
    @dance_threshold = dance_threshold
    @dance_skill = dance_skill
    @stances = stances
    @weapon_training = weapon_training
    @worn_weapons = worn_weapons

    @weapon_name = ''
    @target = -1
    @last_skill = nil
    @twohanded_skills = ['Twohanded Blunt', 'Twohanded Edged', 'Bow']
  end

  def execute(game_state)
    game_state['dancing'] = should_dance?
    should_dance? ? dance(game_state) : determine_next_to_train(game_state)

    weapon_skill = game_state['weapon_skill']

    check_weapon(weapon_skill) if @last_skill != weapon_skill
    check_stance(weapon_skill)
    @last_skill = weapon_skill
    false
  end

  private

  def dance(game_state)
    @last_skill = game_state['weapon_skill']
    game_state['weapon_skill'] = @dance_skill
    @weapon_name = @weapon_training[@dance_skill]
  end

  def determine_next_to_train(game_state)
    return if game_state['action_count'] < 10 && DRSkill.getxp(game_state['weapon_skill']).to_i < @target

    echo("new skill needed for training #{game_state['action_count']}:#{DRSkill.getxp(game_state['weapon_skill']).to_i}:#{@target}") if $debug_mode

    @last_skill = game_state['weapon_skill']
    game_state['action_count'] = 0

    game_state['weapon_skill'], @weapon_name = @weapon_training
                                               .sort_by { |skill, _| [DRSkill.getxp(skill).to_i, DRSkill.getrank(skill).to_i] }
                                               .first
    @target = DRSkill.getxp(game_state['weapon_skill']).to_i + 3
  end

  def should_dance?
    DRRoom.npcs.length <= @dance_threshold || DRRoom.npcs.empty?
  end

  def last_stance
    Flags['last-stance'][0] =~ /(\d+)%.* (\d+)%.* (\d+)%.* (\d+)/
    { 'EVASION' => Regexp.last_match(1).to_i, 'PARRY' => Regexp.last_match(2).to_i, 'SHIELD' => Regexp.last_match(3).to_i, 'SPARE' => Regexp.last_match(4).to_i }
  end

  def build_stance_string(vals)
    "stance set #{vals['EVASION']} #{vals['PARRY']} #{vals['SHIELD']}"
  end

  def check_stance(weapon_skill)
    vals = { 'EVASION' => 0, 'PARRY' => 0, 'SHIELD' => 0, 'SPARE' => 0 }
    skill_map = { 'Parry Ability' => 'Parry', 'Shield Usage' => 'Shield' }
    previous = last_stance
    points = previous.values.inject(&:+)

    if @stances[weapon_skill].nil?
      priority = ['Evasion', 'Parry Ability', 'Shield Usage'].sort_by { |skill| DRSkill.getxp(skill).to_i }
    else
      priority = @stances[weapon_skill]
    end

    priority.each do |skill|
      skill = skill_map[skill] if skill_map[skill]
      vals[skill.upcase] = points >= 100 ? 100 : points
      points -= vals[skill.upcase]
    end

    fput(build_stance_string(vals)) unless vals == previous
  end

  def check_weapon(weapon_skill)
    echo("checking weapons as #{@last_skill}!=#{weapon_skill}") if $debug_mode
    stow_weapons

    if @worn_weapons.include? @weapon_name
      fput("remove #{@weapon_name}") while checkright.nil?
    elsif !@weapon_name.empty?
      attempt = bput("wield #{@weapon_name}", 'Wield what', "You're already", 'right hand and balancing', "right hand\.")
      if attempt == 'Wield what'
        echo("***Could not find weapon #{@weapon_name}. Please update your config script.***")
        stop_script('combat-trainer')
      elsif attempt == 'right hand and balancing' && !@twohanded_skills.include?(weapon_skill)
        echo('***Swapping 2Hander to 1Hander***') if $debug_mode
        fput("swap #{@weapon_name}")
      elsif attempt == 'right hand.' && @twohanded_skills.include?(weapon_skill)
        echo('***Swapping 1Hander to 2Hander***') if $debug_mode
        fput("swap #{@weapon_name}")
      end
    end

    fput('swap') if weapon_skill == 'Offhand Weapon'
  end

  def stow_weapons
    until checkright.nil?
      if @worn_weapons.include? checkright
        fput "wear #{checkright}"
      else
        fput 'stow right'
      end
      fput 'unload' if get =~ /^You (need to|should) unload/
    end

    until checkleft.nil?
      if @worn_weapons.include? checkleft
        fput "wear #{checkleft}"
      else
        fput 'stow left'
      end
      fput 'unload' if get =~ /^You (need to|should) unload/
    end
  end
end

class LootProcess
  include DRC

  def initialize(skin:false, arrange_all:false, arrange_count:0, lootables:[])
    @skin = skin
    @arrange_all = arrange_all
    @arrange_count = arrange_count
    @lootables = lootables
  end

  def execute(game_state)
    game_state['mob_died'] = false
    dispose_body(game_state)
    stow_lootables
    false
  end

  def stow_lootables
    @lootables.each do |item|
      DRRoom.room_objs.grep(/#{item}/).each { |_| fput "stow #{item}" }
    end
  end

  def dispose_body(game_state)
    return if DRRoom.dead_npcs.length < 1
    game_state['mob_died'] = true

    check_skinning if @skin

    bput('loot', 'You search', 'I could not find what you were referring to')
    pause 1
  end

  def check_skinning
    arranges = 0
    arrange_message = @arrange_all ? 'arrange all for skin' : 'arrange for skin'
    while arranges < @arrange_count
      arranges += 1
      case bput(arrange_message, 'You begin to arrange', 'You continue arranging', 'You make a mistake', 'You complete arranging', 'That creature cannot', 'That has already been arranged', 'Arrange what', 'cannot be skinned')
      when 'You complete arranging', 'That has already been arranged'
        break
      when 'Arrange what', 'cannot be skinned'
        return
      when 'That creature cannot'
        arranges = 0
        arrange_message = @arrange_all ? 'arrange all' : 'arrange'
      end
      waitrt?
    end
    pause 0.25
    waitrt?
    bput('skin', 'roundtime')
    waitrt?
  end
end

class SafetyProcess
  include DRC

  def initialize
    @danger = false
    @escape_message = 'You are already as far away as you can get'
    Flags.add('ct-engaged', 'closes to pole weapon range on you', 'closes to melee range on you')
  end

  def execute(_game_state)
    fix_standing
    @danger = in_danger?
  end

  private

  def fix_standing
    return if checkstanding
    fput('stand')
  end

  def retreat
    until @escape_message == bput('retreat', @escape_message, 'retreat')
    end
  end

  def in_danger?
    return false if checkhealth > 75 && !checkbleeding
    unless @danger
      Flags.reset('ct-engaged')
      retreat
    end

    fput 'exit' if checkhealth < 40

    if Flags['ct-engaged']
      retreat
      Flags.reset('ct-engaged')
    end

    if checkbleeding && Script.exists?('tendme') && !running?('tendme')
      start_script('tendme')
    end
    true
  end
end

class SpellProcess
  include DRC

  def initialize(buffs:{}, ospells:[], camb:nil, casts:[], preps:[])
    echo("SpellProcess(#{buffs},#{ospells}, #{camb}, #{casts}, #{preps})") if $debug_mode
    @buff_spells = buffs
    @offensive_spells = ospells
    @cambrinth = camb
    @casts = casts
    @preps = preps

    if (buffs.size > 0 || ospells.length > 0) && (casts.empty? || preps.empty?)
      fail(ArgumentError, 'Must provide casting/prep messages to use spells')
    end

    @prep_spell = false
    @charges = nil
    @previous_skill = nil
    Flags.add('ct-spelllost', 'Your pattern dissipates with the loss of your target')
  end

  def execute(game_state)
    @prep_spell = false if Flags['ct-spelllost']
    check_current if @prep_spell
    bless_thrown(game_state['weapon_skill']) unless @prep_spell
    check_buffs unless @prep_spell
    check_offensive unless @prep_spell || game_state['dancing']
    false
  end

  private

  def bless_thrown(weapon_skill)
    return unless @buff_spells['Bless']
    if @previous_skill != weapon_skill && @thrown_skills.include?[weapon_skill]
      bput('prepare Bless', *@preps)
      bput("cast #{checkright}", *@casts)
    end
    @previous_skill = weapon_skill
  end

  def charge_cambrinth
    return false unless @charges
    echo("charge_camb: #{@charges}") if $debug_mode

    if @charges.length > 0
      bput("charge #{@cambrinth} #{@charges.pop}", '^You harness')
      waitrt?
    else
      bput("invoke #{@cambrinth}", 'You reach for its center')
      @charges = nil
    end
    true
  end

  def check_current
    return if charge_cambrinth
    cast if Flags['ct-spellcast']
  end

  def cast
    case bput('cast', *([@casts] + [/^Your target pattern dissipates/, /^You can't cast that at yourself/]))
    when /^Your target pattern dissipates/, /^You can't cast that at yourself/
      fput('release spell')
    end

    @prep_spell = nil

    return unless @after
    @after.call
    @after = nil
  end

  def check_buffs
    name, data = @buff_spells.find { |name, data| !DRSpells.active_spells[name] || DRSpells.active_spells[name] <= data['recast'] }
    echo("found buff missing: #{name}") if $debug_mode && name
    prepare_spell(data)
  end

  def check_offensive
    return if checkmana < 40
    data = @offensive_spells.sort_by { |spell| DRSkill.getxp(spell['skill']).to_i }.first
    return if DRSkill.getxp(data['skill']).to_i >= 34 # make this a spell option
    prepare_spell(data)
    Flags.reset('ct-spelllost')
  end

  def prepare_spell(data)
    return unless data
    echo("prepare spell: #{data}") if $debug_mode
    command = 'pre'
    command = data['skill'] == 'Debilitation' ? 'pre' : 'tar' if data['skill']
    bput("#{command} #{data['abbrev']} #{data['mana']}", *@preps)
    @prep_spell = true
    @charges = data['cambrinth'].dup if data['cambrinth']
    @after = data['after']
    Flags.reset('ct-spellcast')
  end
end

class AbilityProcesss
  def initialize(buffs:[])
    @buffs = buffs
    @cooldown_timers = {}
  end

  def execute(_game_state)
    check_buffs
    false
  end

  private

  def check_buffs
    @buffs.each do |action, cooldown|
      timer = @cooldown_timers[action]
      next unless !timer || (Time.now - timer).to_i > cooldown
      @cooldown_timers[action] = Time.now
      fput action
      waitrt?
    end
  end
end

class AttackProcess
  include DRC

  def initialize(aim_fillers:[], aim_fillers_stealth:nil, use_charged_maneuvers:false, dance_actions:[], dance_actions_stealth:nil, fatigue_regen_threshold:90, fatigue_regen_action:'bob')
    @aim_fillers = aim_fillers
    @aim_fillers_stealth = aim_fillers_stealth
    @use_charged_maneuvers = use_charged_maneuvers
    @dance_actions = dance_actions
    @dance_actions_stealth = dance_actions_stealth
    @fatigue_regen_threshold = fatigue_regen_threshold
    @fatigue_regen_action = fatigue_regen_action

    @thrown_skills = ['Heavy Thrown', 'Light Thrown']
    @aim_skills = %w(Bow Slings Crossbow)
    @charged_maneuvers = {
      'Brawling' => 'palmstrike',
      'Bow' => 'powershot',
      'Crossbow' => 'powershot',
      'Slings' => 'powershot',
      'Small Edged' => 'cleave',
      'Large Edged' => 'cleave',
      'Twohanded Edged' => 'cleave',
      'Small Blunt' => 'crash',
      'Large Blunt' => 'crash',
      'Twohanded Blunt' => 'crash',
      'Staves' => 'twirl',
      'Polearms' => 'impale'
    }

    @action_queue = []
    @dance_queue = []
    @cooldown_timers = {}
    @loaded = false
    @selected_maneuver = ''
  end

  def execute(game_state)
    if game_state['dancing']
      dance
      return false
    end

    if fatigue_low?
      echo("***Fatigue: #{DRStats.fatigue}***") if $debug_mode
      echo("***Target: #{@fatigue_regen_threshold}***") if $debug_mode
      fput(@fatigue_regen_action)
      return false
    end

    weapon_skill = game_state['weapon_skill']

    charged_maneuver = @use_charged_maneuvers ? check_charged_maneuver(@charged_maneuvers[weapon_skill]) : ''

    if @thrown_skills.include?(weapon_skill)
      attack_thrown(game_state)
    elsif @aim_skills.include?(weapon_skill)
      attack_aimed(charged_maneuver, game_state)
    else
      attack_melee(charged_maneuver, game_state)
    end
    false
  end

  private

  def fatigue_low?
    DRStats.fatigue < @fatigue_regen_threshold
  end

  def attack_melee(charged_maneuver, game_state)
    if charged_maneuver.empty?
      command = game_state['weapon_skill'] == 'Offhand Weapon' ? 'attack left' : 'attack'
      fput(command)
    else
      use_charged_maneuver(charged_maneuver)
    end

    waitrt?

    if reget(5, 'You aren\'t close enough to attack')
      pause 6
    else
      game_state['action_count'] += 1
    end
  end

  def attack_thrown(game_state)
    weapon_name = checkright
    fput 'lob'
    waitrt?
    bput("get #{weapon_name}", 'You are already holding', "You pick up.*#{weapon_name}")
    game_state['action_count'] += 1
  end

  def attack_aimed(charged_maneuver, game_state)
    @selected_maneuver = charged_maneuver unless @loaded
    @loaded = false if game_state['mob_died']

    if @loaded && @action_queue.empty?
      if @selected_maneuver.empty?
        case bput('shoot', "isn't loaded", 'There is nothing', 'But your', 'you fire', 'I could not find', 'with no effect and falls to the ground', 'Face what')
        when 'you fire'
          game_state['action_count'] += 1
        end
        @loaded = false
      else
        use_charged_maneuver @selected_maneuver
        game_state['action_count'] += 1
        @loaded = false
      end
      waitrt?
    elsif @loaded
      fput(@action_queue.shift)
      waitrt?
    else
      bput('load', 'You reach into', 'already loaded')
      waitrt?
      @loaded = true
      if @selected_maneuver.empty?
        @action_queue = get_actions(@aim_fillers, @aim_fillers_stealth, game_state['weapon_skill'])
        bput('aim', 'You begin to target', 'You are already', 'There is nothing else', 'Face what\?', 'You shift your target')
      end
    end
  end

  def get_actions(actions, stealth_actions, weapon_skill)
    echo("get_actions #{actions}:#{stealth_actions}") if $debug_mode

    (stealth_actions && stealth_actions[weapon_skill] && (DRSkill.getxp('Stealth').to_i < 34)) ? stealth_actions[weapon_skill].dup : actions[weapon_skill].dup
  end

  def dance
    if DRRoom.npcs.empty?
      pause 1
    else
      if @dance_queue.empty?
        actions = @dance_actions_stealth && !@dance_actions_stealth.empty? ? @dance_actions_stealth.dup : @dance_actions.dup
        @dance_queue = actions
      end
      fput(@dance_queue.shift)
      waitrt?
    end
  end

  def check_charged_maneuver(charged_maneuver)
    return '' unless charged_maneuver
    timer = @cooldown_timers[charged_maneuver]
    if timer && (Time.now - timer).to_i < 60
      return ''
    else
      echo "***Using charged maneuver: #{charged_maneuver}***" if $debug_mode && !charged_maneuver.empty?
      return charged_maneuver
    end
  end

  def use_charged_maneuver(action)
    fput "maneuver #{action}"
    # Maneuvers have extra non-RT delays
    pause 7
    waitrt?
    @cooldown_timers[action] = Time.now
  end
end

class CombatTrainer
  include DRC
  def main(combat_vars)
    setup

    dance_threshold = combat_vars.dance_threshold
    $debug_mode = combat_vars.combat_trainer_debug
    buff_spells = combat_vars.buff_spells
    aim_fillers_stealth = combat_vars.aim_fillers_stealth
    aim_fillers = combat_vars.aim_fillers
    use_charged_maneuvers = combat_vars.use_charged_maneuvers
    dance_actions_stealth = combat_vars.dance_actions_stealth
    dance_actions = combat_vars.dance_actions
    offensive_spells = combat_vars.offensive_spells
    lootables = combat_vars.lootables
    buff_nonspells = combat_vars.buff_nonspells
    cambrinth = combat_vars.cambrinth
    cast_messages = combat_vars.cast_messages
    prep_messages = combat_vars.prep_messages
    skin = combat_vars.skinning['skin']
    arrange_all = combat_vars.skinning['arrange_all']
    arrange_count = combat_vars.skinning['arrange_count']
    fatigue_regen_threshold = combat_vars.fatigue_regen_threshold
    fatigue_regen_action = combat_vars.fatigue_regen_action
    worn_items = combat_vars.worn_items
    weapon_training = combat_vars.weapon_training
    dance_skill = combat_vars.dance_skill
    worn_weapons = combat_vars.worn_weapons
    stances = combat_vars.stances

    check_equipment(worn_items)

    game_state = {
      'dancing' => false,
      'mob_died' => false,
      'action_count' => 0,
      'weapon_skill' => ''
    }

    combat_processes = [
      SetupProcess.new(dance_threshold: dance_threshold, dance_skill: dance_skill, stances: stances, weapon_training: weapon_training, worn_weapons: worn_weapons),
      SpellProcess.new(buffs: buff_spells, ospells: offensive_spells, camb: cambrinth, casts: cast_messages, preps: prep_messages),
      AbilityProcesss.new(buffs: buff_nonspells),
      LootProcess.new(skin: skin, arrange_all: arrange_all, arrange_count: arrange_count, lootables: lootables),
      SafetyProcess.new,
      AttackProcess.new(
        aim_fillers: aim_fillers, aim_fillers_stealth: aim_fillers_stealth,
        use_charged_maneuvers: use_charged_maneuvers,
        dance_actions: dance_actions, dance_actions_stealth: dance_actions_stealth,
        fatigue_regen_threshold: fatigue_regen_threshold, fatigue_regen_action: fatigue_regen_action
      )
    ]

    loop do
      combat_processes.each do |process|
        break if process.execute(game_state)
      end
    end
  end

  def check_equipment(worn_items)
    return unless worn_items
    combat_items = get_combat_items

    missing_items = worn_items.reject { |item| combat_items.include?(item.description) }

    lost_items = missing_items.reject { |item| wear_item(item) }

    return if lost_items.empty?

    beep
    echo 'MISSING EQUIPMENT: Please verify these items are in a closed container and not lost:'
    echo "#{lost_items.map(&:description).join(', ')}"
    pause
    beep
    pause
    beep
  end

  def setup
    # Run helper scripts
    %w(common drinfomon events spellmonitor).each do |script_name|
      unless running?(script_name)
        start_script script_name
        pause 0.25
      end
    end

    unless $first_combat_run
      $first_combat_run = true
      fput 'exp all'
      pause 1
      fput 'info'
      pause 1
    end

    Flags.add('ct-spellcast', '^Your formation of a targeting pattern around .+ has completed\.', '^You feel fully prepared to cast your spell\.')

    Flags.add('last-stance', 'Setting your Evasion stance to \d+%, your Parry stance to \d+%, and your Shield stance to \d+%.  You have \d+ stance points left')

    fput 'stance set 100 40 40'
    pause 0.25 until Flags['last-stance']
  end
end

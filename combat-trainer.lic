=begin
    Authored by Sheltim and Seped. Suggestions and contributions are welcome: https://github.com/rpherbig/dr-scripts

    This script will train a list of skills in order of the lowest amount of field experience.

    Before running this script for the first time:
    * Download scripts "common", "drinfomon", "events", and "spellmonitor".
    * Set up a configuration script named "combat-trainer-setup".
        * Download "combat-trainer-setup" for an example configuration script.
    * You can turn on debug mode with ;e CombatVars.combat_trainer_debug = true
=end

# TODO: Convert nonspell_buffs to use Flags that trigger off of "wearing off" text
# "You struggle, but find yourself lacking the inner fire to enact such a rage!"
# form python
# You feel your inner fire cool as you finish practicing the Form of the Python.
# berserk avalanche
# The ever-building avalanche of rage within you crashes to a sudden halt!
# berserk earthquake
# An aftershock of rage shudders through you one last time, before your fury crashes to a sudden halt!

# TODO: Handle a nonexistent worn weapon (similar to what is done for wielding)
# "Remove what", "You sling", "You remove", "You aren't wearing that"

# TODO: Alternate skinning options (skin only for skill not loot)

# TODO: Add sniping

# TODO: Train appraise if above a certain rank (100?)

# TODO: spell stance before casting

# TODO: when no enemies in the room don't pause. Instead collect once and kick pile to train perc/outdoors.

# TODO: Handle the case in which two defenses are soft/hard capped. It currently keeps 100/80 those two since they are not gaining field exp, which leaves my third defense unused (and thus it will always be behind the other two).

# TODO: Make stance syntax (in the setup file) flexible enough that I could say "Weapon" => ["shield"] and it would determine the second defensive skill dynamically

# TODO: Warn if armor pieces not worn when starting combat. Or better yet, put on armor.

# TODO: The charged maneuver for the Offhand Weapon skill requires weapons in both hands
# The script currently trains Offhand Weapon with an empty right hand. We should add support for a mainhand weapon.

# TODO: Convert "combat-trainer" to "combat-trainer-engine" and "combat-trainer-setup" to "combat-trainer". This means what was the setup script will now be the script you run. It would manage CombatVars, dependencies, etc. and feed those to the engine script.

def main
    # Run helper scripts
    %w(common drinfomon events spellmonitor).each do |script_name|
        unless running?(script_name)
            start_script script_name
            pause 0.25
        end
    end

    # Configure CombatVars
    unless start_script("combat-trainer-setup", variable.drop(1))
        echo "***Please configure your setup script (open this script for instructions).***"
        stop_script "combat-trainer"
    end

    while running? "combat-trainer-setup"
    end

    fput "exp all"
    pause 1
    fput "info"

    @aim_skills = %w(Bow Slings Crossbow)
    @thrown_skills = [ "Heavy Thrown", "Light Thrown", ]
    @twohanded_skills = [ "Twohanded Blunt", "Twohanded Edged", "Bow" ]
    @cooldown_timers = { }
    @charged_maneuvers = {
        "Brawling" => "palmstrike",
        "Bow" => "powershot",
        "Crossbow" => "powershot",
        "Slings" => "powershot",
        "Small Edged" => "cleave",
        "Large Edged" => "cleave",
        "Twohanded Edged" => "cleave",
        "Small Blunt" => "crash",
        "Large Blunt" => "crash",
        "Twohanded Blunt" => "crash",
        "Staves" => "twirl",
        "Polearms" => "impale",
        #"Offhand Weapon" => "doublestrike",
    }

    Flags.add('ct-spellcast', '^Your formation of a targeting pattern around .+ has completed\.', '^You feel fully prepared to cast your spell\.')

    Flags.add('last-stance', 'Setting your Evasion stance to \d+%, your Parry stance to \d+%, and your Shield stance to \d+%.  You have \d+ stance points left')

    put "stance set 100 40 40"
    while !Flags['last-stance']
        pause 0.25
    end

    check_equipment(CombatVars.worn_items)

    last_skill = nil

    loop do
        last_skill = event_loop(
            last_skill,
            CombatVars.weapon_training,
            CombatVars.dance_skill,
            CombatVars.dance_threshold,
            CombatVars.combat_trainer_debug,
            CombatVars.buff_spells,
            CombatVars.aim_fillers_stealth,
            CombatVars.aim_fillers,
            CombatVars.use_charged_maneuvers,
            CombatVars.dance_actions_stealth,
            CombatVars.dance_actions,
            CombatVars.stances,
            CombatVars.offensive_spells,
            CombatVars.lootables,
            CombatVars.buff_nonspells,
            CombatVars.cambrinth,
            CombatVars.cast_messages,
            CombatVars.skinning,
            CombatVars.worn_weapons,
            CombatVars.fatigue_regen_threshold,
            CombatVars.fatigue_regen_action)
    end
end

def event_loop(last_skill, weapon_training, dance_skill, dance_threshold, debug_mode, buff_spells, aim_fillers_stealth, aim_fillers, use_charged_maneuvers, dance_actions_stealth, dance_actions, stances, offensive_spells, lootables, buff_nonspells, cambrinth, cast_messages, skinning, worn_weapons, fatigue_regen_threshold, fatigue_regen_action)
    # The next skill to train is the one with the lowest field experience
    weapon_skill, weapon_name =
        weapon_training
        .sort_by { |skill, weapon| [DRSkill.getxp(skill).to_i, DRSkill.getrank(skill).to_i] }
        .first

    weapon_skill, weapon_name = [dance_skill, weapon_training[dance_skill]] if should_dance(dance_threshold)

    check_weapon(weapon_skill, weapon_name, worn_weapons, debug_mode) if last_skill != weapon_skill

    set_stance(weapon_skill, stances, debug_mode)

    check_standing

    if checkhealth <= 75 || checkbleeding
        beep
        echo "***LOW ON HEALTH OR BLEEDING***"
        fput "retreat"
        fput "retreat"
        if(checkbleeding && Script.exists?('tendme') && !running?('tendme'))
            start_script('tendme')
        else
            pause 5
        end
        return weapon_skill
    end

    check_dead_npcs(debug_mode, skinning, offensive_spells)
    stow_lootables(lootables)

    if DRSkill.getxp(weapon_skill).to_i >= 34
        echo "***Skills capped***" if debug_mode
    end

    if should_dance(dance_threshold)
        idle_in_room(last_skill, dance_actions_stealth, dance_actions, buff_nonspells, cambrinth, cast_messages, buff_spells, offensive_spells)
        echo "***Too few or no enemies, sleeping***" if debug_mode
        return weapon_skill
    end

    echo "***Attempting to train #{weapon_skill}***" if debug_mode
    target = [34, DRSkill.getxp(weapon_skill).to_i + 3].min
    counter = 0

    while DRSkill.getxp(weapon_skill).to_i < target
        echo "***#{weapon_skill}: #{DRSkill.getxp(weapon_skill).to_i}***" if debug_mode
        echo "***Target: #{target}***" if debug_mode

        check_standing

        break if counter >= 10
        break if DRRoom.npcs.length == 0 && DRRoom.dead_npcs.length == 0
        break if should_dance(dance_threshold)
        check_dead_npcs(debug_mode, skinning, offensive_spells)

        #short term fix for thrown weapons.
        if @thrown_skills.include?(weapon_skill) && buff_spells["Bless"] && !DRSpells.prep_spell
            fput "pre bless"
            fput "cast #{weapon_name}"
            DRSpells.prep_spell = nil
        end

        cast_spell = check_buffs(buff_nonspells, cambrinth, cast_messages, buff_spells)
        check_offensive_spells(offensive_spells) unless cast_spell || DRRoom.npcs.length == 0
        check_fatigue(fatigue_regen_threshold, fatigue_regen_action, debug_mode)
        stow_lootables(lootables)

        counter += 1

        charged_maneuver = get_charged_maneuver(weapon_skill, use_charged_maneuvers, debug_mode)
        if @aim_skills.include? weapon_skill
            bput "load", "You reach into", "already loaded"
            waitrt?

            if charged_maneuver.empty?
                bput "aim", "You begin to target", "You are already", "There is nothing else", 'Face what\?'
                actions = DRSkill.getxp("Stealth").to_i < 34 && aim_fillers_stealth[weapon_skill] ? aim_fillers_stealth[weapon_skill] : aim_fillers[weapon_skill]
                actions.each do |action|
                    fput action
                    waitrt?
                    check_buffs(buff_nonspells, cambrinth, cast_messages, buff_spells)
                end
                bput("shoot", "isn't loaded", "There is nothing", "But your", "you fire", "I could not find", "with no effect and falls to the ground", "Face what")
            else
                use_charged_maneuver charged_maneuver
            end
            waitrt?
        elsif @thrown_skills.include? weapon_skill
            fput "lob"
            waitrt?
            bput("get #{weapon_name}", "You are already holding", "You pick up.*#{weapon_name}")
        else
            if charged_maneuver.empty?
                fput weapon_skill == "Offhand Weapon" ? "attack left" : "attack"
            else
                use_charged_maneuver charged_maneuver
            end
            waitrt?
            if reget 5, "You aren't close enough to attack"
                pause 6
            end
        end
    end

    if counter == 10
        echo "***Weapon appears to be learning slowly, consider removing it from the training list***"
    end

    return weapon_skill
end

def should_dance(dance_threshold)
    DRRoom.npcs.length <= dance_threshold
end

def get_charged_maneuver(weapon_skill, use_charged_maneuvers, debug_mode)
    charged_maneuver = @charged_maneuvers[weapon_skill]
    timer = @cooldown_timers[charged_maneuver]
    if !use_charged_maneuvers || (timer && (Time.now - timer).to_i < 60)
        charged_maneuver = ""
    end
    echo "***Using charged maneuver: #{charged_maneuver}***" if debug_mode
    return charged_maneuver
end

def use_charged_maneuver(action)
    fput "maneuver #{action}"
    waitrt?
    # Maneuvers have extra non-RT setup
    pause 7
    @cooldown_timers[action] = Time.now
end

def idle_in_room(last_skill, dance_actions_stealth, dance_actions, buff_nonspells, cambrinth, cast_messages, buff_spells, offensive_spells)
    kill_offensive_spells(offensive_spells)
    check_buffs(buff_nonspells, cambrinth, cast_messages, buff_spells)

    if DRRoom.npcs.length > 0
        actions = DRSkill.getxp("Stealth").to_i < 34 && dance_actions_stealth ? dance_actions_stealth : dance_actions
        actions.each do |action|
            fput action
            waitrt?
            check_buffs(buff_nonspells, cambrinth, cast_messages, buff_spells)
        end
    else
        3.times do
            pause 5
            check_buffs(buff_nonspells, cambrinth, cast_messages, buff_spells)
        end
    end
end

def last_stance
    Flags['last-stance'][0] =~ /(\d+)%.* (\d+)%.* (\d+)%.* (\d+)/
    {"EVASION"=>$1.to_i, "PARRY"=> $2.to_i, "SHIELD"=>$3.to_i, "SPARE"=>$4.to_i}
end

def build_stance_string(vals)
    "stance set #{vals["EVASION"]} #{vals["PARRY"]} #{vals["SHIELD"]}"
end

def set_stance(weapon_skill, debug_mode)
    vals = {"EVASION"=>0, "PARRY"=> 0, "SHIELD"=>0, "SPARE"=>0}
    skill_map = {"Parry Ability" => "Parry", "Shield Usage"=> "Shield"}
    previous = last_stance
    points = previous.values.inject(&:+)

    if stances[weapon_skill].nil?
        echo "***No stance set for #{weapon_skill}, determining learning priority***" if debug_mode
        priority = ["Evasion", "Parry Ability", "Shield Usage"].sort_by { |skill| DRSkill.getxp(skill).to_i }
    else
        echo "***Stance order set for #{weapon_skill}***" if debug_mode
        priority = stances[weapon_skill]
    end

    priority.each do |skill|
        skill = skill_map[skill] if skill_map[skill]
        vals[skill.upcase] = points >= 100 ? 100 : points
        points -= vals[skill.upcase]
    end

    fput build_stance_string(vals) unless vals == previous
end

def stow_weapons(worn_weapons)
    while checkright != nil
        if worn_weapons.include? checkright
            fput "wear #{checkright}"
        else
            fput "stow right"
        end
        fput "unload" if get =~ /^You (need to|should) unload/
    end

    while checkleft != nil
        if worn_weapons.include? checkleft
            fput "wear #{checkleft}"
        else
            fput "stow left"
        end
        fput "unload" if get =~ /^You (need to|should) unload/
    end
end

def check_offensive_spells(offensive_spells)
    return if DRSpells.prep_spell
    data = offensive_spells.sort_by { |data| DRSkill.getxp(data["skill"]).to_i }.first
    return unless data
    return if DRSkill.getxp(data["skill"]).to_i >= 34
    command = data["skill"] == "Debilitation" ? "pre" : "tar"
    fput "#{command} #{data["abbrev"]} #{data["mana"]}"
    @charges = data["cambrinth"].dup if data["cambrinth"]
    Flags.reset('ct-spellcast')
end

def check_buffs(buff_nonspells, cambrinth, cast_messages, buff_spells)
    buff_nonspells.each do |action, cooldown|
        timer = @cooldown_timers[action]
        if !timer || (Time.now - timer).to_i > cooldown
            @cooldown_timers[action] = Time.now
            fput action
            waitrt?
        end
    end

    if DRSpells.prep_spell
        if @charges
            if @charges.length > 0
                fput "charge #{cambrinth} #{@charges.pop}"
                waitrt?
                return false
            else
                fput "invoke #{cambrinth}"
                @charges = nil
                return false
            end
        end
        if Flags['ct-spellcast']
            bput("cast", *([cast_messages] + [/roundtime/i]) )
            waitrt?
            if @after
                @after.call
                @after = nil
            end
            return true
        end
        return false
    end

    buff_spells.each do |name, data|
        if !DRSpells.active_spells[name] || (DRSpells.active_spells[name] <= data["recast"])
            fput "prepare #{data["abbrev"]} #{data["mana"]}"
            @charges = data["cambrinth"].dup if data["cambrinth"]
            @after = data["after"]
            Flags.reset('ct-spellcast')
            return true
        end
    end
    return false
end

def stow_lootables(lootables)
    lootables.each do |item|
        DRRoom.room_objs.grep(/#{item}/).each { |_| fput "stow #{item}" }
    end
end

def check_dead_npcs(debug_mode, skinning, offensive_spells)
    return if DRRoom.dead_npcs.length < 1

    echo "***Found dead NPCs: #{DRRoom.dead_npcs}***" if debug_mode

    check_skinning(skinning)

    fput "loot"
    kill_offensive_spells(offensive_spells)
end

def check_skinning(skinning)
    return unless skinning["skin"]

    arranges = 0
    arrange_message = skinning["arrange_all"] ? "arrange all for skin" : "arrange for skin"
    while arranges < skinning["arrange_count"]
        arranges += 1
        case bput(arrange_message, "You begin to arrange", "You continue arranging", "You make a mistake", "You complete arranging", "That creature cannot", "That has already been arranged", "Arrange what", "cannot be skinned")
        when "You complete arranging", "That has already been arranged"
            break
        when "Arrange what", "cannot be skinned"
            return
        when "That creature cannot"
            arranges = 0
            arrange_message = skinning["arrange_all"] ? "arrange all" : "arrange"
        end
        waitrt?
    end
    pause 0.25
    waitrt?
    fput "skin"
    waitrt?
end

def kill_offensive_spells(offensive_spells)
    return unless DRSpells.prep_spell
    return unless offensive_spells.select{ |data| data["name"] == DRSpells.prep_spell }.length > 0
    fput "rel spel"
    DRSpells.prep_spell = nil
end

def check_weapon(weapon_skill, weapon_name, worn_weapons, debug_mode)
    stow_weapons(worn_weapons)

    if worn_weapons.include? weapon_name
        while checkright == nil
            fput "remove #{weapon_name}"
        end
    elsif !weapon_name.empty?
        attempt = bput "wield #{weapon_name}", "Wield what", "You're already", "right hand and balancing", "right hand\."

        if attempt == "Wield what"
            echo "***Could not find weapon #{weapon_name}. Please update your config script.***"
            stop_script "combat-trainer"
        elsif attempt == "right hand and balancing" && !@twohanded_skills.include?(weapon_skill)
            echo "***Swapping 2Hander to 1Hander***" if debug_mode
            fput "swap #{weapon_name}"
        elsif attempt == "right hand." && @twohanded_skills.include?(weapon_skill)
            echo "***Swapping 1Hander to 2Hander***" if debug_mode
            fput "swap #{weapon_name}"
        end
    end

    if weapon_skill == "Offhand Weapon"
        fput "swap"
    end
end

def check_fatigue(fatigue_regen_threshold, fatigue_regen_action, debug_mode)
    while DRStats.fatigue < fatigue_regen_threshold
        echo "***Fatigue: #{DRStats.fatigue}***" if debug_mode
        echo "***Target: #{fatigue_regen_threshold}***" if debug_mode
        break if DRRoom.npcs.length == 0

        fput fatigue_regen_action
        waitrt?
    end
end

def check_equipment(worn_items)
    return unless worn_items
    combat_items = get_combat_items

    missing_items = worn_items.reject{ |item| combat_items.include?(item.description) }

    lost_items = missing_items.reject{ |item| wear_item(item) }

    unless lost_items.empty?
        beep
        echo "MISSING EQUIPMENT: Please verify these items are in a closed container and not lost:"
        echo "#{ lost_items.map{|x| x.description}.join(', ') }"
        pause
        beep
        pause
        beep
    end
end

def check_standing
    return if checkstanding
    fput("stand")
end

# Call this last to avoid the need for forward declarations
main

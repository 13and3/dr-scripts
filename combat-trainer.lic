=begin
    Authored by Sheltim and Seped. Suggestions and contributions are welcome: https://github.com/rpherbig/dr-scripts

    This script will be used by combat-trainer-setup to train a list of skills in order of the lowest amount of field experience.

    Before running this script for the first time:
    * Download scripts "common", "drinfomon", "events", and "spellmonitor".

    * Download "combat-trainer-setup" configure it for your use, and run it.
=end

# TODO: when no enemies in the room don't pause. Instead collect once and kick pile to train perc/outdoors.

# TODO: Handle the case in which two defenses are soft/hard capped. It currently keeps 100/80 those two since they are not gaining field exp, which leaves my third defense unused (and thus it will always be behind the other two).
# Is this fixed now that there is a secondary sort on rank?

# TODO: Convert "combat-trainer" to "combat-trainer-engine" and "combat-trainer-setup" to "combat-trainer". This means what was the setup script will now be the script you run. It would manage CombatVars, dependencies, etc. and feed those to the engine script.

class SetupProcess
  def initialize

  end

  def execute

  end

end

class LootProcess
  def initialize
  end

  def execute

  end

end

class SafetyProcess

  def initialize
  end

  def execute
    fix_standing
    in_danger?
  end

  private

  def fix_standing
    return if checkstanding
    fput('stand')
  end

  def in_danger?
    return false if checkhealth > 75 && !checkbleeding

    fput 'exit' if checkhealth < 40

    echo '***LOW ON HEALTH OR BLEEDING***'
    escape_message = 'You are already as far away as you can get'
    until escape_message == bput('retreat', escape_message, 'retreat')
    end

    if checkbleeding && Script.exists?('tendme') && !running?('tendme')
      start_script('tendme')
    end

    true
  end

end

class SpellProcess
  def initialize(buffs:{}, ospells:[], camb:nil, casts:[], preps:[])
    @buff_spells = buff_spells
    @offensive_spells = offensive_spells
    @cambrinth = camb
    @casts = casts
    @preps = preps

    if (buffs.size > 0 || ospells.length > 0) && (casts.length == 0 || preps.length == 0)
      raise(ArgumentError, 'Must provide casting/prep messages to use spells')
    end

    @prep_spell = false
    @charges = nil
    @previous_skill
  end

  def execute
    check_current
    bless_thrown unless @prep_spell
    check_buffs unless @prep_spell
    check_offensive unless @prep_spell
    false
  end

  private

  def bless_thrown
    return unless @buff_spells['Bless']
    new_skill = SetupProcess.current_skill
    if @previous_skill != new_skill && @thrown_skills.include?[new_skill]
      bput('prepare Bless', *@preps)
      bput("cast #{SetupProcess.current_weapon}", *@casts)
    end
    @previous_skill = new_skill
  end

  def charge_cambrinth
    false unless @charges

    if @charges.length > 0
      fput "charge #{cambrinth} #{@charges.pop}"
      waitrt?
    else
      fput "invoke #{cambrinth}"
      @charges = nil
    end
    true
  end

  def check_current
    return unless @prep_spell
    return if charge_cambrinth
    cast if Flags['ct-spellcast']
  end

  def cast
    case bput('cast', *([cast_messages] + [/^Your target pattern dissipates/, /roundtime/i]))
    when /roundime/i
      waitrt?
    when /^Your target pattern dissipates/
      fput("release spell")
    end

    @prep_spell = nil

    if @after
      @after.call
      @after = nil
    end
  end

  def check_buffs
    _, data = @buff_spells.find{|name,data| DRSpells.active_spells[name] && DRSpells.active_spells[name] <= data['recast'] }
    prep_spell(data)
  end

  def check_offensive
    data = offensive_spells.sort_by { |data| DRSkill.getxp(data['skill']).to_i }.first
    return if DRSkill.getxp(data['skill']).to_i >= 34 #make this a spell option
    prep_spell(data)
  end

  def prepare_spell(data)
    return unless data
    command = 'pre'
    command = data['skill'] == 'Debilitation' ? 'pre' : 'tar' if data['skill']
    bput("#{command} #{data['abbrev']} #{data['mana']}", *@preps)
    @prep_spell = true
    @charges = data['cambrinth'].dup if data['cambrinth']
    @after = data['after']
    Flags.reset('ct-spellcast')
  end

end

class AbilityProcesss
  def initialize(buffs:[])
    @buffs = buffs
    @cooldown_timers = {}
  end

  def execute
    check_buffs
  end

  private

  def check_buffs
    @buffs.each do |action, cooldown|
      timer = @cooldown_timers[action]
      next unless !timer || (Time.now - timer).to_i > cooldown
      @cooldown_timers[action] = Time.now
      fput action
      waitrt?
    end
  end

end

class AttackProcess

  def initialize()
  end

  def execute

  end

end


def main
  setup

  thrown_skills = ['Heavy Thrown', 'Light Thrown']
  aim_skills = %w(Bow Slings Crossbow)
  twohanded_skills = ['Twohanded Blunt', 'Twohanded Edged', 'Bow']
  charged_maneuvers = {
    'Brawling' => 'palmstrike',
    'Bow' => 'powershot',
    'Crossbow' => 'powershot',
    'Slings' => 'powershot',
    'Small Edged' => 'cleave',
    'Large Edged' => 'cleave',
    'Twohanded Edged' => 'cleave',
    'Small Blunt' => 'crash',
    'Large Blunt' => 'crash',
    'Twohanded Blunt' => 'crash',
    'Staves' => 'twirl',
    'Polearms' => 'impale',
    # "Offhand Weapon" => "doublestrike",
  }

  dance_threshold = CombatVars.dance_threshold
  $debug_mode = CombatVars.combat_trainer_debug
  buff_spells = CombatVars.buff_spells
  aim_fillers_stealth = CombatVars.aim_fillers_stealth
  aim_fillers = CombatVars.aim_fillers
  use_charged_maneuvers = CombatVars.use_charged_maneuvers
  dance_actions_stealth = CombatVars.dance_actions_stealth
  dance_actions = CombatVars.dance_actions
  offensive_spells = CombatVars.offensive_spells
  lootables = CombatVars.lootables
  buff_nonspells = CombatVars.buff_nonspells
  cambrinth = CombatVars.cambrinth
  cast_messages = CombatVars.cast_messages
  skinning = CombatVars.skinning
  fatigue_regen_threshold = CombatVars.fatigue_regen_threshold
  fatigue_regen_action = CombatVars.fatigue_regen_action
  worn_items = CombatVars.worn_items
  weapon_training = CombatVars.weapon_training
  dance_skill = CombatVars.dance_skill
  worn_weapons = CombatVars.worn_weapons
  stances = CombatVars.stances

  check_equipment(worn_items)

  combat_processes =   [
    SetupProcess.new(dance_threshold:dance_threshold, dance_skill:dance_skill, stances:stances, weapon_training:weapon_training)
    SpellProcess.new(buffs:buff_spells, ospells:offensive_spells, camb: cambrinth, casts: cast_messages),
    AbilityProcesss.new(buffs:buff_nonspells),
    LootProcess.new,
    SafetyProcess.new,
    AttackProcess.new
  ]

  loop do
    combat_processes.each do |process|
      break if process.execute
    end
  end

  loop do
    weapon_skill, weapon_name = determine_next_to_train(weapon_training, dance_skill, dance_threshold)

    check_weapon(weapon_skill, weapon_name, worn_weapons, debug_mode, twohanded_skills) if last_skill != weapon_skill

    set_stance(weapon_skill, stances, debug_mode)



    next if in_danger?

    check_dead_npcs(debug_mode, skinning, offensive_spells)
    stow_lootables(lootables)

    if DRSkill.getxp(weapon_skill).to_i >= 34
      echo '***Skills capped***' if debug_mode
    end

    last_skill = weapon_skill

    next if should_idle?(dance_threshold, dance_actions_stealth, dance_actions, buff_nonspells, cambrinth, cast_messages, buff_spells, offensive_spells, debug_mode)

    event_loop(
      weapon_skill,
      weapon_name,
      dance_threshold,
      debug_mode,
      buff_spells,
      aim_fillers_stealth,
      aim_fillers,
      use_charged_maneuvers,
      offensive_spells,
      lootables,
      buff_nonspells,
      cambrinth,
      cast_messages,
      skinning,
      fatigue_regen_threshold,
      fatigue_regen_action,
      thrown_skills.include?(weapon_skill),
      aim_skills.include?(weapon_skill),
      charged_maneuvers)
  end
end

def event_loop(weapon_skill, weapon_name, dance_threshold, debug_mode, buff_spells, aim_fillers_stealth, aim_fillers, use_charged_maneuvers, offensive_spells, lootables, buff_nonspells, cambrinth, cast_messages, skinning, fatigue_regen_threshold, fatigue_regen_action, is_thrown_weapon, is_aimed_weapon, charged_maneuvers)
  echo "***Attempting to train #{weapon_skill}***" if debug_mode
  target = [34, DRSkill.getxp(weapon_skill).to_i + 3].min
  counter = 0

  while DRSkill.getxp(weapon_skill).to_i < target
    echo "***#{weapon_skill}: #{DRSkill.getxp(weapon_skill).to_i}***" if debug_mode
    echo "***Target: #{target}***" if debug_mode

    check_standing

    break if counter >= 10
    break if DRRoom.npcs.empty? && DRRoom.dead_npcs.empty?
    break if should_dance?(dance_threshold)
    check_dead_npcs(debug_mode, skinning, offensive_spells)

    bless_thrown_weapon(buff_spells, weapon_name) if is_thrown_weapon

    cast_spell = check_buffs(buff_nonspells, cambrinth, cast_messages, buff_spells)
    check_offensive_spells(offensive_spells) unless cast_spell || DRRoom.npcs.empty?
    check_fatigue(fatigue_regen_threshold, fatigue_regen_action, debug_mode)
    stow_lootables(lootables)

    counter += 1

    charged_maneuver = should_use_charged_maneuver?(use_charged_maneuvers, debug_mode, charged_maneuvers[weapon_skill]) ? charged_maneuvers[weapon_skill] : ''

    if is_aimed_weapon
      bput 'load', 'You reach into', 'already loaded'
      waitrt?

      if charged_maneuver.empty?
        bput 'aim', 'You begin to target', 'You are already', 'There is nothing else', 'Face what\?'
        actions = get_actions(aim_fillers_stealth, aim_fillers, weapon_skill)
        actions.each do |action|
          fput action
          waitrt?
          check_buffs(buff_nonspells, cambrinth, cast_messages, buff_spells)
          check_standing
        end
        bput('shoot', "isn't loaded", 'There is nothing', 'But your', 'you fire', 'I could not find', 'with no effect and falls to the ground', 'Face what')
      else
        use_charged_maneuver charged_maneuver
      end
      waitrt?
    elsif is_thrown_weapon
      fput 'lob'
      waitrt?
      bput("get #{weapon_name}", 'You are already holding', "You pick up.*#{weapon_name}")
    else
      if charged_maneuver.empty?
        fput weapon_skill == 'Offhand Weapon' ? 'attack left' : 'attack'
      else
        use_charged_maneuver charged_maneuver
      end
      waitrt?
      pause 6 if reget 5, "You aren't close enough to attack"
    end
  end

  if counter == 10
    echo '***Weapon appears to be learning slowly, consider removing it from the training list***'
  end
end

def should_dance?(dance_threshold)
  DRRoom.npcs.length <= dance_threshold
end

def should_use_charged_maneuver?(use_charged_maneuvers, debug_mode, charged_maneuver)
  timer = @cooldown_timers[charged_maneuver]
  if !use_charged_maneuvers || (timer && (Time.now - timer).to_i < 60)
    echo '***Not using charged maneuver***' if debug_mode
    return false
  else
    echo "***Using charged maneuver: #{charged_maneuver}***" if debug_mode
    return true
  end
end

def use_charged_maneuver(action)
  fput "maneuver #{action}"
  waitrt?
  # Maneuvers have extra non-RT setup
  pause 7
  @cooldown_timers[action] = Time.now
end

def idle_in_room(dance_actions_stealth, dance_actions, buff_nonspells, cambrinth, cast_messages, buff_spells, offensive_spells)
  kill_offensive_spells(offensive_spells)
  check_buffs(buff_nonspells, cambrinth, cast_messages, buff_spells)

  if DRRoom.npcs.length > 0
    actions = dance_actions_stealth && DRSkill.getxp('Stealth').to_i < 34 ? dance_actions_stealth : dance_actions
    actions.each do |action|
      fput action
      waitrt?
      check_buffs(buff_nonspells, cambrinth, cast_messages, buff_spells)
    end
  else
    3.times do
      pause 5
      check_buffs(buff_nonspells, cambrinth, cast_messages, buff_spells)
    end
  end
end

def last_stance
  Flags['last-stance'][0] =~ /(\d+)%.* (\d+)%.* (\d+)%.* (\d+)/
  { 'EVASION' => Regexp.last_match(1).to_i, 'PARRY' => Regexp.last_match(2).to_i, 'SHIELD' => Regexp.last_match(3).to_i, 'SPARE' => Regexp.last_match(4).to_i }
end

def build_stance_string(vals)
  "stance set #{vals['EVASION']} #{vals['PARRY']} #{vals['SHIELD']}"
end

def set_stance(weapon_skill, stances, debug_mode)
  vals = { 'EVASION' => 0, 'PARRY' => 0, 'SHIELD' => 0, 'SPARE' => 0 }
  skill_map = { 'Parry Ability' => 'Parry', 'Shield Usage' => 'Shield' }
  previous = last_stance
  points = previous.values.inject(&:+)

  if stances[weapon_skill].nil?
    echo "***No stance set for #{weapon_skill}, determining learning priority***" if debug_mode
    priority = ['Evasion', 'Parry Ability', 'Shield Usage'].sort_by { |skill| DRSkill.getxp(skill).to_i }
  else
    echo "***Stance order set for #{weapon_skill}***" if debug_mode
    priority = stances[weapon_skill]
  end

  priority.each do |skill|
    skill = skill_map[skill] if skill_map[skill]
    vals[skill.upcase] = points >= 100 ? 100 : points
    points -= vals[skill.upcase]
  end

  fput build_stance_string(vals) unless vals == previous
end

def stow_weapons(worn_weapons)
  until checkright.nil?
    if worn_weapons.include? checkright
      fput "wear #{checkright}"
    else
      fput 'stow right'
    end
    fput 'unload' if get =~ /^You (need to|should) unload/
  end

  until checkleft.nil?
    if worn_weapons.include? checkleft
      fput "wear #{checkleft}"
    else
      fput 'stow left'
    end
    fput 'unload' if get =~ /^You (need to|should) unload/
  end
end


def stow_lootables(lootables)
  lootables.each do |item|
    DRRoom.room_objs.grep(/#{item}/).each { |_| fput "stow #{item}" }
  end
end

def check_dead_npcs(debug_mode, skinning, offensive_spells)
  return if DRRoom.dead_npcs.length < 1

  echo "***Found dead NPCs: #{DRRoom.dead_npcs}***" if debug_mode

  check_skinning(skinning)

  fput 'loot'
  kill_offensive_spells(offensive_spells)
end

def check_skinning(skinning)
  return unless skinning['skin']

  arranges = 0
  arrange_message = skinning['arrange_all'] ? 'arrange all for skin' : 'arrange for skin'
  while arranges < skinning['arrange_count']
    arranges += 1
    case bput(arrange_message, 'You begin to arrange', 'You continue arranging', 'You make a mistake', 'You complete arranging', 'That creature cannot', 'That has already been arranged', 'Arrange what', 'cannot be skinned')
    when 'You complete arranging', 'That has already been arranged'
      break
    when 'Arrange what', 'cannot be skinned'
      return
    when 'That creature cannot'
      arranges = 0
      arrange_message = skinning['arrange_all'] ? 'arrange all' : 'arrange'
    end
    waitrt?
  end
  pause 0.25
  waitrt?
  fput 'skin'
  waitrt?
end

def kill_offensive_spells(offensive_spells)
  return unless DRSpells.prep_spell
  return unless offensive_spells.count { |data| data['name'] == DRSpells.prep_spell } > 0
  fput 'rel spel'
  DRSpells.prep_spell = nil
end

def check_weapon(weapon_skill, weapon_name, worn_weapons, debug_mode, twohanded_skills)
  stow_weapons(worn_weapons)

  if worn_weapons.include? weapon_name
    fput "remove #{weapon_name}" while checkright.nil?
  elsif !weapon_name.empty?
    attempt = bput "wield #{weapon_name}", 'Wield what', "You're already", 'right hand and balancing', "right hand\."

    if attempt == 'Wield what'
      echo "***Could not find weapon #{weapon_name}. Please update your config script.***"
      stop_script 'combat-trainer'
    elsif attempt == 'right hand and balancing' && !twohanded_skills.include?(weapon_skill)
      echo '***Swapping 2Hander to 1Hander***' if debug_mode
      fput "swap #{weapon_name}"
    elsif attempt == 'right hand.' && twohanded_skills.include?(weapon_skill)
      echo '***Swapping 1Hander to 2Hander***' if debug_mode
      fput "swap #{weapon_name}"
    end
  end

  fput 'swap' if weapon_skill == 'Offhand Weapon'
end

def check_fatigue(fatigue_regen_threshold, fatigue_regen_action, debug_mode)
  while DRStats.fatigue < fatigue_regen_threshold
    echo "***Fatigue: #{DRStats.fatigue}***" if debug_mode
    echo "***Target: #{fatigue_regen_threshold}***" if debug_mode
    break if DRRoom.npcs.empty?

    fput fatigue_regen_action
    waitrt?
  end
end

def check_equipment(worn_items)
  return unless worn_items
  combat_items = get_combat_items

  missing_items = worn_items.reject { |item| combat_items.include?(item.description) }

  lost_items = missing_items.reject { |item| wear_item(item) }

  unless lost_items.empty?
    beep
    echo 'MISSING EQUIPMENT: Please verify these items are in a closed container and not lost:'
    echo "#{lost_items.map(&:description).join(', ')}"
    pause
    beep
    pause
    beep
  end
end

def determine_next_to_train(weapon_training, dance_skill, dance_threshold)
  if should_dance?(dance_threshold)
    weapon_skill = dance_skill
    weapon_name = weapon_training[dance_skill]
  else
    # The next skill to train is the one with the lowest field experience
    # Break ties by training the one with the lowest rank
    weapon_skill, weapon_name =
        weapon_training
        .sort_by { |skill, _weapon| [DRSkill.getxp(skill).to_i, DRSkill.getrank(skill).to_i] }
        .first
  end
  [weapon_skill, weapon_name]
end

def should_idle?(dance_threshold, dance_actions_stealth, dance_actions, buff_nonspells, cambrinth, cast_messages, buff_spells, offensive_spells, debug_mode)
  return false unless should_dance?(dance_threshold)

  echo '***Too few or no enemies, idling***' if debug_mode
  idle_in_room(dance_actions_stealth, dance_actions, buff_nonspells, cambrinth, cast_messages, buff_spells, offensive_spells)

  true
end

def setup
  # Run helper scripts
  %w(common drinfomon events spellmonitor).each do |script_name|
    unless running?(script_name)
      start_script script_name
      pause 0.25
    end
  end

  unless $first_combat_run
    $first_combat_run = true
    fput 'exp all'
    pause 1
    fput 'info'
    pause 1
  end



  Flags.add('ct-spellcast', '^Your formation of a targeting pattern around .+ has completed\.', '^You feel fully prepared to cast your spell\.')

  Flags.add('last-stance', 'Setting your Evasion stance to \d+%, your Parry stance to \d+%, and your Shield stance to \d+%.  You have \d+ stance points left')

  put 'stance set 100 40 40'
  pause 0.25 until Flags['last-stance']
end

def get_actions(stealth_actions, nonstealth_actions, weapon_skill)
  stealth_actions && stealth_actions[weapon_skill] && DRSkill.getxp('Stealth').to_i < 34 ? stealth_actions[weapon_skill] : nonstealth_actions[weapon_skill]
end

# Call this last to avoid the need for forward declarations
main

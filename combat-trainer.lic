=begin
    Authored by Sheltim and Seped. Suggestions and contributions are welcome: https://github.com/rpherbig/dr-scripts

    This script will train a list of skills in order of the lowest amount of field experience.

    Before running this script for the first time:
    * Download scripts "common", "drinfomon", "events", and "spellmonitor".
    * Set up a configuration script named "combat-trainer-setup".
        * Download "combat-trainer-setup" for an example configuration script.
    * You can turn on debug mode with ;e UserVars.combat_trainer_debug = true
=end

# TODO: Convert nonspell_buffs to use Flags that trigger off of "wearing off" text
# "You struggle, but find yourself lacking the inner fire to enact such a rage!"
# form python
# You feel your inner fire cool as you finish practicing the Form of the Python.
# berserk avalanche
# The ever-building avalanche of rage within you crashes to a sudden halt!
# berserk earthquake
# An aftershock of rage shudders through you one last time, before your fury crashes to a sudden halt!

# TODO: Add clear to the top of the main loop?
# https://gswiki.play.net/mediawiki/index.php/Lich_scripting_reference#clear

# TODO: Handle a nonexistent worn weapon (similar to what is done for wielding)
# "Remove what", "You sling", "You remove", "You aren't wearing that"

# TODO: Alternate skinning options (skin only for skill not loot)

# TODO: Add sniping

# TODO: Train appraise if above a certain rank (100?)

# TODO: spell stance before casting

# TODO: add a dance weapon

# TODO: when no enemies in the room don't pause. Instead collect once and kick pile to train perc/outdoors.

# TODO: Handle the case in which two defenses are soft/hard capped. It currently keeps 100/80 those two since they are not gaining field exp, which leaves my third defense unused (and thus it will always be behind the other two).

# TODO: Make stance syntax (in the setup file) flexible enough that I could say "Weapon" => ["shield"] and it would determine the second defensive skill dynamically

# TODO: Should still loot while xp capped dancing.

# TODO: Warn if armor pieces not worn when starting combat. Or better yet, put on armor.

# TODO: The charged maneuver for the Offhand Weapon skill requires weapons in both hands
# The script currently trains Offhand Weapon with an empty right hand. We should add support for a mainhand weapon.

# TODO: Convert "combat-trainer" to "combat-trainer-engine" and "combat-trainer-setup" to "combat-trainer". This means what was the setup script will now be the script you run. It would manage UserVars, dependencies, etc. and feed those to the engine script.

# TODO: If there are no mobs but you are below the fatigue threshold, the script will spam the fatigue regen action until your fatigue naturally regenerates.

# TODO: Check dance threshold INSIDE the combat loop

def main
    # Run helper scripts
    %w(common drinfomon events spellmonitor).each do |script_name|
        unless running?(script_name)
            start_script script_name
            pause 0.25
        end
    end

    # Configure UserVars
    unless start_script("combat-trainer-setup", variable.drop(1))
        echo "***Please configure your setup script (open this script for instructions).***"
        stop_script "combat-trainer"
    end

    while running? "combat-trainer-setup"
    end

    fput "exp all"
    pause 1
    fput "info"

    @aim_skills = %w(Bow Slings Crossbow)
    @thrown_skills = [ "Heavy Thrown", "Light Thrown", ]
    @twohanded_skills = [ "Twohanded Blunt", "Twohanded Edged", "Bow" ]
    @cooldown_timers = { }
    @charged_maneuvers = {
        "Brawling" => "palmstrike",
        "Bow" => "powershot",
        "Crossbow" => "powershot",
        "Slings" => "powershot",
        "Small Edged" => "cleave",
        "Large Edged" => "cleave",
        "Twohanded Edged" => "cleave",
        "Small Blunt" => "crash",
        "Large Blunt" => "crash",
        "Twohanded Blunt" => "crash",
        "Staves" => "twirl",
        "Polearms" => "impale",
        #"Offhand Weapon" => "doublestrike",
    }

    Flags.add('ct-spellcast', '^Your formation of a targeting pattern around .+ has completed\.', '^You feel fully prepared to cast your spell\.')

    Flags.add('last-stance', 'Setting your Evasion stance to \d+%, your Parry stance to \d+%, and your Shield stance to \d+%.  You have \d+ stance points left')

    put "stance set 100 40 40"
    while !Flags['last-stance']
        pause 0.25
    end

    last_skill = nil

    loop do
        last_skill = event_loop(last_skill)
    end
end

def event_loop(last_skill)
    # The next skill to train is the one with the lowest field experience
    weapon_skill, weapon_name = UserVars.weapon_training.sort_by { |skill, weapon| DRSkill.getxp(skill).to_i }.first

    weapon_skill, weapon_name = [UserVars.dance_skill, UserVars.weapon_training[UserVars.dance_skill]] if should_dance

    check_weapon(weapon_skill, weapon_name) if last_skill != weapon_skill

    set_stance weapon_skill

    if checkhealth <= 75 || checkbleeding
        beep
        echo "***LOW ON HEALTH OR BLEEDING***"
        fput "retreat"
        fput "retreat"
        if(Script.exists?('tendme') && !running?('tendme'))
            start_script('tendme')
        else
            pause 5
        end
        return weapon_skill
    end

    check_dead_npcs
    stow_lootables

    if checkbleeding
        echo "\a"
        echo "***YOU'RE BLEEDING, WATCH YOUR VITALITY***"
    end

    if DRSkill.getxp(weapon_skill).to_i >= 34
        echo "***Skills capped***" if UserVars.combat_trainer_debug
    end

    if should_dance
        idle_in_room last_skill
        echo "***Too few or no enemies, sleeping***" if UserVars.combat_trainer_debug
        return weapon_skill
    end

    echo "***Attempting to train #{weapon_skill}***" if UserVars.combat_trainer_debug
    target = [34, DRSkill.getxp(weapon_skill).to_i + 3].min
    counter = 0

    while DRSkill.getxp(weapon_skill).to_i < target
        echo "***#{weapon_skill}: #{DRSkill.getxp(weapon_skill).to_i}***" if UserVars.combat_trainer_debug
        echo "***Target: #{target}***" if UserVars.combat_trainer_debug

        break if counter >= 10
        break if DRRoom.npcs.length == 0 && DRRoom.dead_npcs.length == 0
        break if should_dance
        check_dead_npcs

        #short term fix for thrown weapons.
        if @thrown_skills.include?(weapon_skill) && UserVars.buff_spells["Bless"] && !DRSpells.prep_spell

            fput "pre bless"
            fput "cast #{weapon_name}"
        end



        cast_spell = check_buffs
        check_offensive_spells unless cast_spell || DRRoom.npcs.length == 0
        check_fatigue
        stow_lootables

        counter += 1

        charged_maneuver = get_charged_maneuver weapon_skill
        if @aim_skills.include? weapon_skill
            bput "load", "You reach into", "already loaded"
            waitrt?

            if charged_maneuver.empty?
                bput "aim", "You begin to target", "You are already", "There is nothing else", 'Face what\?'
                actions = DRSkill.getxp("Stealth").to_i < 34 && UserVars.aim_fillers_stealth[weapon_skill] ? UserVars.aim_fillers_stealth[weapon_skill] : UserVars.aim_fillers[weapon_skill]
                actions.each do |action|
                    fput action
                    waitrt?
                    check_buffs
                end
                bput("shoot", "isn't loaded", "There is nothing", "But your", "you fire", "I could not find", "with no effect and falls to the ground", "Face what")
            else
                use_charged_maneuver charged_maneuver
            end
            waitrt?
        elsif @thrown_skills.include? weapon_skill
            fput "lob"
            waitrt?
            bput("get #{weapon_name}", "You are already holding", "You pick up.*#{weapon_name}")
        else
            if charged_maneuver.empty?
                fput weapon_skill == "Offhand Weapon" ? "attack left" : "attack"
            else
                use_charged_maneuver charged_maneuver
            end
            waitrt?
            if reget 5, "You aren't close enough to attack"
                pause 3
            end
        end
    end

    if counter == 10
        echo "***Weapon appears to be learning slowly, consider removing it from the training list***"
    end

    return weapon_skill
end

def should_dance
    DRRoom.npcs.length <= UserVars.dance_threshold
end

def get_charged_maneuver(weapon_skill)
    charged_maneuver = @charged_maneuvers[weapon_skill]
    timer = @cooldown_timers[charged_maneuver]
    if !UserVars.use_charged_maneuvers || (timer && (Time.now - timer).to_i < 60)
        charged_maneuver = ""
    end
    echo "***Using charged maneuver: #{charged_maneuver}***" if UserVars.combat_trainer_debug
    return charged_maneuver
end

def use_charged_maneuver(action)
    fput "maneuver #{action}"
    waitrt?
    # Maneuvers have extra non-RT setup
    pause 7
    @cooldown_timers[action] = Time.now
end

def idle_in_room(last_skill)
    kill_offensive_spells
    check_buffs

    # weapon_skill = UserVars.dance_skill || last_skill
    # weapon_name = UserVars.weapon_training[weapon_skill]

    # check_weapon(weapon_skill, weapon_name) if last_skill != weapon_skill

    # last_stance = set_stance(weapon_skill, last_stance)

    if DRRoom.npcs.length > 0
        actions = DRSkill.getxp("Stealth").to_i < 34 && UserVars.dance_actions_stealth ? UserVars.dance_actions_stealth : UserVars.dance_actions
        actions.each do |action|
            fput action
            waitrt?
            check_buffs
        end
    else
        pause 5
        check_buffs
        pause 5
        check_buffs
        pause 5
        check_buffs
    end
end

def last_stance
    Flags['last-stance'][0] =~ /(\d+)%.* (\d+)%.* (\d+)%.* (\d+)/
    {"EVASION"=>$1.to_i, "PARRY"=> $2.to_i, "SHIELD"=>$3.to_i, "SPARE"=>$4.to_i}
end

def build_stance_string(vals)
    "stance set #{vals["EVASION"]} #{vals["PARRY"]} #{vals["SHIELD"]}"
end

def set_stance(weapon_skill)
    vals = {"EVASION"=>0, "PARRY"=> 0, "SHIELD"=>0, "SPARE"=>0}
    skill_map = {"Parry Ability" => "Parry", "Shield Usage"=> "Shield"}
    previous = last_stance
    points = previous.values.inject(&:+)

    if UserVars.stances[weapon_skill].nil?
        echo "***No stance set for #{weapon_skill}, determining learning priority***" if UserVars.combat_trainer_debug
        priority = ["Evasion", "Parry Ability", "Shield Usage"].sort_by { |skill| DRSkill.getxp(skill).to_i }
    else
        echo "***Stance order set for #{weapon_skill}***" if UserVars.combat_trainer_debug
        priority = UserVars.stances[weapon_skill]
    end

    priority.each do |skill|
        skill = skill_map[skill] if skill_map[skill]
        vals[skill.upcase] = points >= 100 ? 100 : points
        points -= vals[skill.upcase]
    end

    fput build_stance_string(vals) unless vals == previous
end

def stow_weapons
    while checkright != nil
        if UserVars.worn_weapons.include? checkright
            fput "wear #{checkright}"
        else
            fput "stow right"
        end
        fput "unload" if get =~ /^You (need to|should) unload/
    end

    while checkleft != nil
        if UserVars.worn_weapons.include? checkleft
            fput "wear #{checkleft}"
        else
            fput "stow left"
        end
        fput "unload" if get =~ /^You (need to|should) unload/
    end
end

def check_offensive_spells
    return if DRSpells.prep_spell
    data = UserVars.offensive_spells.sort_by { |data| DRSkill.getxp(data["skill"]).to_i }.first
    return unless data
    return if DRSkill.getxp(data["skill"]).to_i >= 34
    command = data["skill"] == "Debilitation" ? "pre" : "tar"
    fput "#{command} #{data["abbrev"]} #{data["mana"]}"
    @charges = data["cambrinth"].dup if data["cambrinth"]
    Flags.reset('ct-spellcast')
end

def check_buffs
    UserVars.buff_nonspells.each do |action, cooldown|
        timer = @cooldown_timers[action]
        if !timer || (Time.now - timer).to_i > cooldown
            @cooldown_timers[action] = Time.now
            fput action
            waitrt?
        end
    end

    if DRSpells.prep_spell
        if @charges
            if @charges.length > 0
                fput "charge #{UserVars.cambrinth} #{@charges.pop}"
                waitrt?
                return false
            else
                fput "invoke #{UserVars.cambrinth}"
                @charges = nil
                return false
            end
        end
        if Flags['ct-spellcast']
            fput "cast"
            if @after
                @after.each{|message| fput message }
                @after = nil
            end
            return true
        end
        return false
    end

    UserVars.buff_spells.each do |name, data|
        if !DRSpells.active_spells[name] || (DRSpells.active_spells[name] <= data["recast"])
            fput "prepare #{data["abbrev"]} #{data["mana"]}"
            @charges = data["cambrinth"].dup if data["cambrinth"]
            @after = data["after"]
            Flags.reset('ct-spellcast')
            return true
        end
    end
    return false
end

def stow_lootables
    UserVars.lootables.each do |item|
        DRRoom.room_objs.grep(/#{item}/).each { |_| fput "stow #{item}" }
    end
end

def check_dead_npcs
    return if DRRoom.dead_npcs.length < 1

    echo "***Found dead NPCs: #{DRRoom.dead_npcs}***" if UserVars.combat_trainer_debug

    check_skinning

    fput "loot"
    kill_offensive_spells
end

def check_skinning
    if UserVars.skinning["skin"]
        arranges = 0
        arrange_message = UserVars.skinning["arrange_all"] ? "arrange all for skin" : "arrange for skin"
        while arranges < UserVars.skinning["arrange_count"]
            arranges += 1
            case bput(arrange_message, "You begin to arrange", "You continue arranging", "You make a mistake", "You complete arranging", "That creature cannot", "That has already been arranged", "Arrange what", "cannot be skinned")
            when "You complete arranging", "That has already been arranged"
                break
            when "Arrange what", "cannot be skinned"
                return
            when "That creature cannot"
                arranges = 0
                arrange_message = UserVars.skinning["arrange_all"] ? "arrange all" : "arrange"
            end
            waitrt?
        end
        pause 0.25
        waitrt?
        fput "skin"
        waitrt?
    end
end

def kill_offensive_spells
    return unless DRSpells.prep_spell
    return unless UserVars.offensive_spells.select{ |data| data["name"] == DRSpells.prep_spell }.length > 0
    fput "rel spel"
end

def check_weapon(weapon_skill, weapon_name)
    stow_weapons

    if UserVars.worn_weapons.include? weapon_name
        while checkright == nil
            fput "remove #{weapon_name}"
        end
    elsif !weapon_name.empty?
        attempt = bput "wield #{weapon_name}", "Wield what", "You're already", "right hand and balancing", "right hand\."

        if attempt == "Wield what"
            echo "***Could not find weapon #{weapon_name}. Please update your config script.***"
            stop_script "combat-trainer"
        elsif attempt == "right hand and balancing" && !@twohanded_skills.include?(weapon_skill)
            echo "***Swapping 2Hander to 1Hander***" if UserVars.combat_trainer_debug
            fput "swap #{weapon_name}"
        elsif attempt == "right hand." && @twohanded_skills.include?(weapon_skill)
            echo "***Swapping 1Hander to 2Hander***" if UserVars.combat_trainer_debug
            fput "swap #{weapon_name}"
        end
    end

    if weapon_skill == "Offhand Weapon"
        fput "swap"
    end
end

def check_fatigue
    while DRStats.fatigue < UserVars.fatigue_regen_threshold
        echo "***Fatigue: #{DRStats.fatigue}***" if UserVars.combat_trainer_debug
        echo "***Target: #{UserVars.fatigue_regen_threshold}***" if UserVars.combat_trainer_debug
        break if DRRoom.npcs.length == 0

        fput UserVars.fatigue_regen_action
        waitrt?
    end
end

# Call this last to avoid the need for forward declarations
main

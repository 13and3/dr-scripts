=begin
  Suggestions and contributions are welcome: https://github.com/rpherbig/dr-scripts

  This script will train a list of skills in order of the lowest amount of field experience. It is intended to be used in The Crossing (https://elanthipedia.play.net/mediawiki/index.php/RanikMap1).

  You can turn on debug mode with ;e UserVars.crossing_trainer_debug = true
=end

custom_require.call(%w(drinfomon equipmanager events spellmonitor common common-travel common-summoning common-money common-crafting))

class CrossingTraining
  include DRC
  include DRCC
  include DRCM
  include DRCS
  include DRCT

  attr_reader :running, :idling

  def stop
    @stop = true
  end

  def initialize
    @stop = false
    @running = true
    @idling = false
    arg_definitions = [[]]

    args = parse_args(arg_definitions, true)

    @settings = get_settings(args.flex + %w(art athletics perform stealing constellations))
    @use_research = @settings.use_research(false)
    @settings.outdoor_room ||= 793
    @song_list = @settings.perform_options
    @settings.storage_containers([]).each { |container| fput("open my #{container}") }
    @disciplines_to_skill = {
      'Blacksmithing' => 'Forging',
      'Weaponsmithing' => 'Forging',
      'Armorsmithing' => 'Forging',
      'Tailoring' => 'Outfitting',
      'Shaping' => 'Engineering',
      'Carving' => 'Engineering'
    }
    @skills_requiring_movement = @settings.crossing_training_requires_movement(%w(Appraisal Athletics Attunement Empathy Engineering Forging Outfitting Scouting Sorcery Stealth Thievery Theurgy Trading))
  end

  def main
    setup

    loop do
      event_loop
      if @idling
        pause 30
        @idling = false
      end
      next unless @stop && !@researching
      @running = false
      stop_play
      break
    end
  end

  def setup
    # Configure UserVars

    EquipmentManager.instance.refresh(@settings)

    UserVars.crossing_timers ||= {}
    UserVars.stealing_timers ||= {}

    fput('release aewo') if DRSpells.active_spells['Aether Wolves']

    Flags.add('ct-spellcast', '^You feel fully prepared to cast your spell\.')
    Flags.add('ct-song', 'you finish playing')
    Flags.add('ct-spell-fail', 'Currently lacking the skill to complete the pattern', 'backfires')
    Flags.add('research-partial', 'there is still more to learn before you arrive at a breakthrough', 'distracted by combat', 'distracted by your spellcasting', 'You lose your focus on your research project', 'you forget what you were')
    Flags.add('research-complete', '^Breakthrough!')

    @bad_classes = %w(Thievery Sorcery)
    @bad_classes += ['Arcana'] if DRStats.barbarian?
    @bad_classes += ['Arcana', 'Inner Magic', 'Targeted Magic', 'Life Magic', 'Holy Magic', 'Lunar Magic', 'Elemental Magic', 'Arcane Magic', 'Attunement', 'Utility', 'Augmentation', 'Debilitation', 'Warding'] if DRStats.trader?
    @bad_classes += ['Arcana', 'Targeted Magic', 'Life Magic', 'Holy Magic', 'Lunar Magic', 'Elemental Magic', 'Arcane Magic', 'Attunement', 'Warding'] if DRStats.thief?
  end

  def empty_trash
    dispose_trash(checkright) while @settings.trash_nouns([]).include?(checkright)
    dispose_trash(checkleft) while @settings.trash_nouns([]).include?(checkleft)
  end

  def event_loop
    empty_trash
    EquipmentManager.instance.empty_hands

    # The next skill to train is the one with the lowest field experience
    skill = @settings.crossing_training([])
                     .select { |s| ready_to_use?(s) }
                     .select { |s| not_research_blocked?(s) }
                     .min_by { |s| DRSkill.getxp(s) }

    unless @skills_requiring_movement.include?(skill)
      walk_to(@settings.safe_room)

      # TODO: Your teacher is not here, so you are no longer learning anything.
      check_listening
    end

    check_research

    check_osrel unless @researching

    if skill.nil? || skill.empty? || DRSkill.getxp(skill) >= 28
      if @researching
        echo '***Skills capped and researching***' if UserVars.crossing_trainer_debug
        pause 30
      else
        @idling = true
        echo '***Skills capped, sleeping***' if UserVars.crossing_trainer_debug
        fput 'exit' if @settings.exit_on_skills_capped
        play_song?
      end

      # Output a harmless command to prevent being logged out
      fput 'tdp'
      return
    end

    stop_play unless @researching

    echo "***Attempting to train #{skill}***" if UserVars.crossing_trainer_debug

    update_timer(skill)

    case skill
    when 'Appraisal'
      train_appraisal
    when 'Athletics'
      train_athletics
    when 'Arcana', 'Life Magic', 'Holy Magic', 'Lunar Magic', 'Elemental Magic', 'Arcane Magic'
      do_research skill
    when 'Astrology'
      train_astrology
    when 'Attunement'
      train_attunement
    when 'Augmentation', 'Warding', 'Utility', 'Debilitation'
      train_magic skill
    when 'Empathy'
      train_empathy
    when 'Engineering'
      train_engineering
    when 'First Aid'
      train_first_aid
    when 'Forging'
      train_forging
    when 'Locksmithing'
      train_locksmithing
    when 'Mechanical Lore'
      train_mechanical_lore
    when 'Outdoorsmanship'
      train_outdoorsmanship
    when 'Outfitting'
      train_outfitting
    when 'Perception'
      train_outdoorsmanship
    when 'Performance'
      train_performance
    when 'Scholarship'
      train_scholarship
    when 'Scouting'
      train_scouting
    when 'Sorcery'
      train_sorcery
    when 'Stealth'
      train_stealth
    when 'Summoning'
      train_summoning
    when 'Theurgy'
      train_theurgy
    when 'Thievery'
      train_thievery
    when 'Trading'
      train_trading
    else
      echo "#{skill} not implemented yet"
      pause 15
    end
  end

  def train_sorcery
    if DRSkill.getrank('Sorcery') < 70
      focus_runestone
    else
      walk_to @settings.crossing_training_sorcery_room(1137)
      spell = @settings.crossing_training_sorcery(nil)
      return if spell.nil? || spell.empty?

      Flags.reset('ct-spellcast')
      fput "prep #{spell}"
      pause 0.5 until Flags['ct-spellcast']
      fput 'cast'
    end
  end

  def focus_runestone
    bput('get my runestone', 'You get')
    until DRSkill.getxp('Sorcery') >= 32
      bput('focus my runestone', 'You focus your magical senses')
      waitrt?
    end
    bput('stow runestone', 'You put your')
  end

  def check_listening
    return unless @settings.listen(false)
    return if listen?(@last_teacher, @bad_classes)
    return if DRRoom.pcs.empty?
    return unless @listen_timer.nil? || Time.now - @listen_timer > 300

    case bput('assess teach', 'is teaching a class', 'No one seems to be teaching', 'You are teaching a class')
    when 'No one seems to be teaching', 'You are teaching a class'
      @listen_timer = Time.now
      @last_teacher = nil
      waitrt?
      return
    else
      @listen_timer = nil
    end
    results = reget(20, 'is teaching a class')
    waitrt?

    classes = results.each_with_object({}) do |line, hash|
      line.match(/(.*) is teaching a class on (.*) which is still open to new students/) do |match|
        teacher = match[1]
        skill = match[2]
        # Some classes match the first format, some have additional text in the 'skill' string that needs to be filtered
        skill.match(/.* \(compared to what you already know\) (.*)/) { |m| skill = m[1] }
        hash[teacher] = skill
      end
    end

    @last_teacher = classes
                    .reject { |t, s| t.nil? || s.nil? }
                    .reject { |_t, s| @bad_classes.include? s }
                    .sort_by { |_t, s| [DRSkill.getxp(s), DRSkill.getrank(s)] }
                    .find { |t, _s| listen?(t, @bad_classes) }
                    .first

    @listen_timer = Time.now unless @last_teacher
  end

  def train_summoning
    summon_weapon
    EquipmentManager.instance.empty_hands unless break_summoned_weapon?(checkright) && break_summoned_weapon?(checkleft)
    fput 'pathway focus damage'
  end

  def train_locksmithing
    start_time = Time.now
    wait_for_script_to_complete('pick')
    if Time.now - start_time > 15
      wait_for_script_to_complete('sell-loot')
    else
      echo '***UNABLE TO TRAIN LOCKSMITHING, REMOVING IT FROM THE TRAINING LIST***'
      @settings.crossing_training([]).delete('Locksmithing')
    end
  end

  def train_theurgy
    wait_for_script_to_complete('theurgy')
  end

  def train_magic(skill)
    if @settings.train_with_spells(true)
      return if checkmana < 40
      @use_research && @settings.research_skills([]).include?(skill) ? do_research(skill) : cast_spell(@settings.training_spells({})[skill], skill)
    else
      cast_nonspell(skill)
    end
  end

  def not_research_blocked?(skill)
    return true unless @use_research
    return (['Summoning', 'Attunement', 'Athletics', 'Outdoorsmanship', 'Perception', 'Appraisal', 'Empathy', 'Mechanical Lore'] - @settings.research_skills([])).include?(skill) if @researching

    if ['Life Magic', 'Holy Magic', 'Lunar Magic', 'Elemental Magic', 'Arcane Magic', 'Arcana'].include?(skill)
      return @settings.research_skills([]).include?(skill) && DRSkill.getxp(skill) < 18
    elsif %w(Warding Utility Augmentation Attunement).include?(skill)
      return @settings.research_skills([]).include?(skill) && DRSkill.getxp(skill) < 9
    end
    true
  end

  def ready_to_use?(skill)
    return true unless UserVars.crossing_timers[skill]
    (Time.now - UserVars.crossing_timers[skill]) > get_skill_timer(skill)
  end

  def get_skill_timer(skill)
    @settings.exp_timers[skill]['cooldown'] || 14
  end

  def update_timer(skill)
    UserVars.crossing_timers[skill] = Time.now
  end

  def cast_nonspell(skill)
    ability = @settings.training_nonspells({})[skill]
    echo("using ability: #{ability}") if UserVars.crossing_trainer_debug
    if ability.include?('Khri')
      unless DRSpells.active_spells[ability]
        fput('kneel') if @settings.kneel_khri(false)
        bput(ability, *@settings.khri_preps)
        waitrt?
        fix_standing
      end
    else
      fput ability
    end
  end

  def calculate_mana(min, more, discern_data, cyclic)
    total = min + more
    total = (total * @settings.prep_scaling_factor).floor
    discern_data['mana'] = [(total / 4.0).ceil, min].max
    remaining = total - discern_data['mana']
    if remaining > @settings.cambrinth_cap
      discern_data['mana'] = discern_data['mana'] + (remaining - @settings.cambrinth_cap)
      remaining = total - discern_data['mana']
    end
    if cyclic
      discern_data['cambrinth'] = nil
      discern_data['mana'] = discern_data['mana'] + remaining
    elsif remaining > 0
      discern_data['cambrinth'] = []
      step_size = (remaining / 3.0).ceil
      while remaining > 0
        discern_data['cambrinth'] << [remaining, step_size].min
        remaining -= step_size
      end
    else
      discern_data['cambrinth'] = nil
    end
  end

  def check_discern(data)
    UserVars.discerns = {} unless UserVars.discerns
    discern_data = UserVars.discerns[data['abbrev']] || {}
    discern_data['time_stamp'] ||= 0 unless discern_data.empty?
    if data['symbiosis']
      if discern_data.empty? || discern_data['min'].nil?
        /requires at minimum (\d+) mana streams/ =~ bput("discern #{data['abbrev']}", 'requires at minimum \d+ mana streams')
        discern_data['mana'] = Regexp.last_match(1).to_i
        discern_data['cambrinth'] = nil
        discern_data['min'] = Regexp.last_match(1).to_i
        discern_data['more'] = 0
      end
      calculate_mana(discern_data['min'], discern_data['more'], discern_data, false)
    elsif discern_data.empty? || Time.now - discern_data['time_stamp'] > 24 * 60 * 60
      discern_data['time_stamp'] = Time.now
      case discern = bput("discern #{data['abbrev']}", 'The spell requires at minimum \d+ mana streams and you think you can reinforce it with \d+ more', 'You don\'t think you are able to cast this spell')
      when /you don't think you are able/i
        discern_data['mana'] = 1
        discern_data['cambrinth'] = nil
      else
        discern =~ /minimum (\d+) mana streams and you think you can reinforce it with (\d+) more/i
        calculate_mana(Regexp.last_match(1).to_i, Regexp.last_match(2).to_i, discern_data, data['cyclic'])
      end
    end
    pause 1
    waitrt?
    UserVars.discerns[data['abbrev']] = discern_data
    data['mana'] = discern_data['mana']
    data['cambrinth'] = discern_data['cambrinth']
  end

  def check_osrel
    return unless @settings.osrel_amount && DRSpells.active_spells['Osrel Meraud']
    bput("harness #{@settings.osrel_amount}", 'You tap into') unless @settings.osrel_no_harness
    waitrt?
    until 'as if it hungers for more' != bput("infuse om #{@settings.osrel_amount}", 'having reached its full capacity', 'as if it hungers for more', 'a sense of fullness')
      pause 0.5
      waitrt?
      bput("harness #{@settings.osrel_amount}", 'You tap into') unless @settings.osrel_no_harness
      waitrt?
    end
    waitrt?
  end

  def research
    if 'You cannot begin' == bput("research #{@researching} 300", 'You focus', 'You tentatively', 'You confidently', 'Abandoning the normal', 'You cannot begin')
      fput('research cancel')
      fput('research cancel')
      research
    end
  end

  def check_research
    return unless @researching
    if Flags['research-partial']
      Flags.reset('research-partial')
      check_osrel
      research
    elsif Flags['research-complete']
      Flags.reset('research-complete')
      @researching = nil
    end
  end

  def do_research(skill)
    unless @use_research
      echo "Tried to use spell research to train #{skill} with it disabled, please correct YAML."
      return
    end

    return if @stop

    Flags.reset('research-partial')
    Flags.reset('research-complete')

    until DRSpells.active_spells['Gauge Flow'] > 20
      cast_spell({ 'abbrev' => 'GAF' }, nil)
      pause 2
    end
    @researching = case skill
                   when 'Arcana', 'Life Magic', 'Holy Magic', 'Lunar Magic', 'Elemental Magic', 'Arcane Magic'
                     'FUNDAMENTAL'
                   when 'Attunement'
                     'STREAM'
                   else
                     skill.upcase
                   end
    research
  end

  def cast_spell(data, skill)
    Flags.reset('ct-spellcast')
    check_discern(data)
    if data['abbrev'] =~ /^comp/i
      walk_to 991
      fput(['\'Had this been a real compost your belongings would be gone. Composting soon', '\'Compost', '\'Compost incoming', '\'This is a code green, compost alert', '\'Pick up your valuables, compost time', '\'If it\'s on the ground it\'s gone, Compost incoming'].sample)
    end

    if (data['abbrev'] =~ /locat/i) && !DRSpells.active_spells['Clear Vision']
      fput('prep cv')
      pause 5
      fput('cast')
    end

    if data['moon']
      moon = UserVars.moons['visible'].first
      unless moon
        echo "No moon available to cast #{data['abbrev']}"
        unless Script.running? 'moonwatch'
          echo 'moonwatch is not running. Starting it now'
          custom_requir.call('moonwatch')
          echo "Run `;e autostart('moonwatch')` to avoid this in the future"
        end
        weather = bput('weather', 'inside', 'You glance up at the sky.')
        walk_to @settings.outdoor_room if weather =~ /inside/
        fput('perceive moons')
        unless moon = UserVars.moons['visible'].first
          echo "Couldn't find any moons to cast #{data['abbrev']} with"
          return
        end
      end
      data['cast'] = "cast #{moon}"
    end

    fput('release gj') if data['cyclic'] && DRSpells.active_spells['Glythtide\'s Joy']
    fput('release care') if data['cyclic'] && DRSpells.active_spells['Caress of the Sun']

    if data['cambrinth'] && @settings.held_cambrinth
      command = @settings.stored_cambrinth ? 'get' : 'remove'
      fput "#{command} my #{@settings.cambrinth}"
    end

    bput('prep symb', 'You recall the exact details of the', 'But you\'ve already prepared') if data['symbiosis']

    scaled_prep_mana = data['mana']
    if /Something in the area interferes/ =~ bput("prepare #{data['abbrev']} #{scaled_prep_mana}", *@settings.prep_messages)
      fput('rel symb') if data['symbiosis']
      return
    end
    if data['cambrinth']
      data['cambrinth'].each do |mana|
        case bput("charge my #{@settings.cambrinth} #{mana}", '^You harness a', "You'll have to hold it")
        when "You'll have to hold it"
          bput("get my #{@settings.cambrinth}", 'You get', 'What were you referring to')
        end
        waitrt?
      end
      bput("invoke my #{@settings.cambrinth}", 'You reach for its center', 'Your link to the', 'shows signs of having been charged')
      pause
      waitrt?

      if data['cambrinth'] && @settings.held_cambrinth && DRSkill.getrank('Arcana').to_i >= @settings.cambrinth_cap * 2 + 100
        command = @settings.stored_cambrinth ? 'stow' : 'wear'
        fput "#{command} my #{@settings.cambrinth}"
      end
    end

    pause 0.5 until Flags['ct-spellcast']

    snapshot = DRSkill.getxp(skill) if data['symbiosis']

    Flags.reset('ct-spell-fail')

    while DRSpells.prep_spell
      data['before'].each { |action| bput(action['message'], action['matches']) }
      fput(data['cast'] || 'cast')
      data['after'].each { |action| bput(action['message'], action['matches']) }
    end

    if data['cambrinth'] && @settings.held_cambrinth && DRSkill.getrank('Arcana').to_i < @settings.cambrinth_cap * 2 + 100
      command = @settings.stored_cambrinth ? 'stow' : 'wear'
      fput "#{command} my #{@settings.cambrinth}"
    end

    return unless data['symbiosis']

    start = Time.now
    pause 0.5 until snapshot != DRSkill.getxp(skill) || Time.now - start > 10 || Flags['ct-spell-fail']
    if Flags['ct-spell-fail']
      fput('rel symb')
      UserVars.discerns[data['abbrev']]['more'] = [UserVars.discerns[data['abbrev']]['more'] - 1, 0].max
    elsif DRSkill.getxp(skill) - snapshot <= 1
      UserVars.discerns[data['abbrev']]['more'] = UserVars.discerns[data['abbrev']]['more'] + 1
    end
  end

  def braid_to_fail(item)
    return if checkleft || checkright
    return unless forage?(item)
    loop do
      waitrt?
      check_research
      case bput("braid my #{item}", 'You Need to have more', 'Roundtime', 'You need both hands to do that', 'You can\'t braid the .* into your braided')
      when 'Roundtime'
        rt = reget(10, 'Roundtime').last.scan(/\d+/).first.to_i
        break if rt >= 8 || DRSkill.getxp('Mechanical Lore') >= 30
      when 'You need both hands to do that', /into your braided/
        waitrt?
        empty_trash
        return
      else
        break unless forage?(item)
      end
    end
    pause 1
    waitrt?
    bput("pull my #{item}", 'You tug and pull')
    pause 1
    waitrt?
    empty_trash
  end

  def train_performance
    unless play_song?(true)
      echo '***UNABLE TO TRAIN PERFORMANCE, REMOVING IT FROM THE TRAINING LIST***'
      @settings.crossing_training([]).delete('Performance')
      return
    end
  end

  def train_outdoorsmanship
    if DRSkill.getrank('Outdoorsmanship') < 30
      forage?('rock')
      dispose_trash 'rock'
    else
      item = if @settings.forage_item
               @settings.forage_item
             else
               'rock'
             end
      bput("collect #{item}", 'You manage to collect', 'The room is too cluttered to find anything here')
      waitrt?
      kick_pile? unless kick_pile?("#{item}s")
    end
  end

  def train_first_aid
    play_song?
    fput 'get my compendium'
    start_text = bput('look my compendium', '^The compendium lies open to the section on .* physiology')
    start_text =~ /^The compendium lies open to the section on (.*) physiology/i
    start = Regexp.last_match(1)
    attempts = 0
    loop do
      study = bput('study my compendium', 'you begin to study', 'you begin studying', 'With a sudden moment of', 'In a sudden moment of clarity', '^Why ', 'you continue to study', 'you attempt', 'you continue studying')
      waitrt?
      attempts += 1
      next if study =~ /^you attempt/i && attempts < 2
      attempts = 0
      match_text = bput 'turn my compendium', '^You turn to the section containing (.*) physiology'
      match_text =~ /^You turn to the section containing (.*) physiology/i
      match = Regexp.last_match(1)
      break if start == match || DRSkill.getxp('First Aid') >= 30
    end
    EquipmentManager.instance.empty_hands
  end

  def train_scholarship
    play_song?

    case bput('get my black book', 'What were you', 'You get')
    when 'What were you'
      echo '***UNABLE TO TRAIN SCHOLARSHIP, REMOVING IT FROM THE TRAINING LIST***'
      @settings.crossing_training([]).delete('Scholarship')
      return
    end

    fput('turn my book to chapter 6')
    14.times do |count|
      bput("turn my book to page #{count + 1}", 'You turn your book to page', 'You are already on')
      bput('study my book', 'roundtime')
      waitrt?
    end
    fput 'stow my book'
  end

  def train_mechanical_lore
    EquipmentManager.instance.empty_hands
    fput "remove #{@settings.hand_armor}"
    fput "stow #{@settings.hand_armor}"
    pause 1
    if @settings.braid_item
      braid_to_fail(@settings.braid_item)
    else
      braid_to_fail(DRSkill.getrank('Outdoorsmanship') < 110 ? 'grass' : 'vine')
    end
    EquipmentManager.instance.empty_hands
    fput "get my #{@settings.hand_armor}"
    fput "wear my #{@settings.hand_armor}"
  end

  def climb?(room, targets)
    targets.each do |target|
      walk_to(room)
      return true if DRRoom.npcs.length >= 3

      fput "climb #{target}"
      pause
      waitrt?
      return false if DRSkill.getxp('Athletics') >= 30
    end
    true
  end

  def train_athletics
    if DRSkill.getrank('Athletics') >= 400
      climb_branch
    else
      play_song?
      @settings.athletics_options.each do |data|
        check_research
        break unless climb?(data['room'], data['targets'])
      end
    end
  end

  def climb_branch
    walk_to(19_074)
    check_research
    if DRSkill.getxp('Athletics') < 29
      walk_to(2245)
      check_research
      fput('hide') until checkhidden
      pause 1
      while DRSkill.getxp('Athletics') < 29
        bput('climb practice branch', 'You begin to practice ')
        Flags.add('ct-climbing', 'You finish practicing')
        loop do
          pause 1
          break if Flags['ct-climbing']
          if DRSkill.getxp('Athletics') > 28
            fput('stop climb')
            break
          end
        end
      end
    end
    check_research
    walk_to(1894)
  end

  def train_empathy
    [8266, 850, 7902, 19_077, 815, 793, 8265, 4652, 19_093, 19_078].each do |room_id|
      walk_to(room_id)
      until 'You sense:' == bput('perceive health', 'You fail to sense', 'You sense:', 'You\'re not ready to do that again, yet')
        pause 1
        rt = waitrt?
        pause 5 if rt.nil? || rt == 0
        check_research
      end
      waitrt?
      break if DRSkill.getxp('Empathy') >= 30
    end
  end

  def train_scouting
    start_room = 991
    return_room = 1378
    if @settings.trail_override
      start_room, return_room = @settings.trail_override
    end

    walk_to start_room
    bput 'scout trail', 'You notice a trailmarker'
    bput 'go trail', 'You set off into the wild', 'That would be difficult'
    waitfor 'As your journey ends'
    pause 0.5 until Room.current.id
    walk_to return_room
    bput 'scout trail', 'You notice a trailmarker'
    bput 'go trail', 'You set off into the wild', 'That would be difficult'
    waitfor 'As your journey ends'
    pause 0.5 until Room.current.id
  end

  def train_attunement
    if @use_research && @settings.research_skills([]).include?('Attunement')
      do_research('Attunement')
      return
    end
    if DRStats.moon_mage?
      fput('perc mana')
      pause 15
      waitrt?
      return
    end
    %w(815 814 802 800 799 801 817 818).each do |roomid|
      walk_to roomid
      bput('perc', 'You reach out')
      waitrt?
      break if DRSkill.getxp('Attunement') >= 30
    end
  end

  def hide_in(room_number)
    walk_to room_number
    fput 'hide'
    waitrt?
    fput 'unhide'
    waitrt?
  end

  def train_stealth
    hide_in 851
    hide_in 850
    hide_in 764
    hide_in 5992
    hide_in 992
  end

  def thievery_is_appropriate(data, skill, targets)
    upper_keys = @difficulty_keys[0..2]

    if data['acceptable_min'] && data['acceptable_min'] <= skill && data['acceptable_max'] >= skill
      if (data['acceptable_max'] + data['acceptable_min']) / 2 <= skill
        targets[0] << data
      else
        targets[1] << data
      end
      return
    end

    if data['trivial_min'] && data['trivial_min'] <= skill && data['trivial_max'] >= skill
      return
    end

    upper_keys.reverse.each_with_index do |diff, index|
      next unless data["#{diff}_min"]
      if (data["#{diff}_min"] + data["#{diff}_max"]) / 2 + (skill * 0.10 * index) < skill
        targets[1] << data
        return
      end
    end

    if data['acceptable_max'] && data['acceptable_max'] + 1 == skill && data['poorly_min'] != skill
      targets[0] << data
      return
    end
    if data['acceptable_min'] && data['acceptable_min'] - 1 == skill && data['rather_max'] != skill
      targets[1] << data
      return
    end

    if data['acceptable_max'] && skill > data['acceptable_max']
      targets[2] << data
    end
  end

  def train_thievery
    start_script('jail-buddy') unless Script.running?('jail-buddy')

    @stealing_attempts = @settings.stealing_attempts

    thievery_skill = DRSkill.getrank('Thievery')

    @difficulty_keys = %w(exceptionally very rather acceptable poorly vpoorly nearly trivial)

    targets = [[], [], []]

    @settings.stealing_options.each do |data|
      next unless UserVars.stealing_timers[data['room']].nil? || Time.now > UserVars.stealing_timers[data['room']]
      thievery_is_appropriate(data, thievery_skill, targets)
    end

    per_room_target = {}

    targets.each do |set|
      set.each do |data|
        per_room_target[data['room']] ||= data
      end
    end

    targets = per_room_target.values
    return if targets.empty?

    EquipmentManager.instance.wear_equipment_set?('stealing')
    @bin_items = []
    targets.each { |target| steal(target) }
    EquipmentManager.instance.wear_equipment_set?('standard')

    unless @bin_items.empty?
      walk_to 6017
      move('tap knocker')
      move('north')

      @bin_items.each do |item|
        fput("get #{item} from my #{@settings.stealing_bag}")
        fput("put #{item} in bin")
        stow_hands
      end

      move('south')
      move('go door')
    end
  end

  def bin_item
    waitrt?
    # Account for being arrested
    # Items can end up in different hands and you may have an items from a previous theft
    [checkright, checkleft].each do |item|
      next unless item
      if @settings.bin_stolen(false)
        @bin_items.push(item)
        bput("put my #{item} in my #{@settings.stealing_bag}", 'You put')
      else
        fput "drop my #{item}"
      end
    end
    waitrt?
  end

  def update_target(target, difficulty)
    skill = DRSkill.getrank('Thievery')

    return if target["#{difficulty}_min"] && skill >= target["#{difficulty}_min"] && skill <= target["#{difficulty}_max"]

    echo("update required for :#{target}") if UserVars.crossing_trainer_debug

    lower_keys = @difficulty_keys[0..@difficulty_keys.index(difficulty)] - [difficulty]
    upper_keys = @difficulty_keys[@difficulty_keys.index(difficulty) + 1..-1]

    update = {}

    if target["#{difficulty}_min"].nil? || skill < target["#{difficulty}_min"]
      update["#{difficulty}_min"] = skill
      lower_keys.each do |diff|
        update["#{diff}_min"] = skill - 1 if target["#{diff}_min"] && target["#{diff}_min"] >= skill
        update["#{diff}_max"] = skill - 1 if target["#{diff}_max"] && target["#{diff}_max"] >= skill
      end
    end
    if target["#{difficulty}_max"].nil? || skill > target["#{difficulty}_max"]
      update["#{difficulty}_max"] = skill
      upper_keys.each do |diff|
        update["#{diff}_min"] = skill + 1 if target["#{diff}_min"] && target["#{diff}_min"] <= skill
        update["#{diff}_max"] = skill + 1 if target["#{diff}_max"] && target["#{diff}_max"] <= skill
      end
    end

    update['trivial_max'] = 1750 if update['trivial_max']

    echo("update:#{update}") if UserVars.crossing_trainer_debug

    @settings.stealing_options.each { |data| data.merge!(update) if data['id'] == target['id'] }
    submit_thieving_update(target['id'], update)
  end

  def make_grab(target, count)
    if @settings.hide_to_steal
      fput 'hide'
      pause 2
      waitrt?
    end
    item = target['item']
    in_message = target['item_in']
    waitrt?
    count += 1
    case bput("steal #{item} #{in_message}",
              'You learned exceptionally well from this nearly impossible theft',
              'You learned very well from this extremely difficult theft',
              'You learned rather well from this difficult theft',
              'You learned acceptably from this theft',
              "You don't feel you learned anything useful from this trivial theft",
              'You learned somewhat poorly from this simple theft',
              'You learned very poorly from this very simple theft',
              'You learned quite badly from this nearly trivial theft',
              'realize that you are being watched and should back off',
              'Roundtime')
    when /this trivial theft/
      update_target(target, 'trivial')
      bin_item
    when /nearly trivial theft/
      update_target(target, 'nearly')
      bin_item
      make_grab(target, count) if count < 4
    when /very poorly/
      update_target(target, 'vpoorly')
      bin_item
      make_grab(target, count) if count < 3
    when /somewhat poorly/
      update_target(target, 'poorly')
      bin_item
      make_grab(target, count) if count < 3
    when /learned acceptably/
      update_target(target, 'acceptable')
      bin_item
      if (target['acceptable_max'] + target['acceptable_min']) / 2 <= DRSkill.getrank('Thievery')
        make_grab(target, count) if count < @settings.stealing_low_acceptable_count
      elsif count < @settings.stealing_high_acceptable_count
        make_grab(target, count)
      end
    when /learned rather well/
      update_target(target, 'rather')
      bin_item
    when /learned very well/
      update_target(target, 'very')
      bin_item
    when /learned exceptionally/
      update_target(target, 'exceptionally')
      bin_item
    when /back off/
    else
      bin_item
      beep
      echo('new learning message: PLEASE SUBMIT')
    end
  end

  def steal(target)
    return if DRSkill.getxp('Thievery') >= 30 && !@settings.steal_past_mindlock
    unless walk_to(target['room'], false)
      UserVars.stealing_timers[target['room']] = Time.now + 60 * 10
      echo("night pause for #{target}") if UserVars.crossing_trainer_debug
      return
    end
    UserVars.stealing_timers[target['room']] = Time.now + 60 * 60
    echo("putting target on cooldown :#{target}") if UserVars.crossing_trainer_debug
    waitrt?
    make_grab(target, 0)
  end

  def train_appraisal
    study_art unless assess_zills?
  end

  def study_art
    @settings.art_options.each do |data|
      break unless study?(data['room'], data['targets'])
    end
  end

  def study?(room, targets)
    walk_to(room)
    targets.each do |target|
      fput "study #{target}"
      waitrt?
      return false if DRSkill.getxp('Appraisal') >= 30
    end
    true
  end

  def assess_zills?
    return false if DRSkill.getrank('Appraisal') >= 250 && !@researching

    EquipmentManager.instance.empty_hands
    case bput('remove my zill', 'You slide', 'Remove what')
    when 'Remove what'
      return false
    end
    bput('assess my zill', 'you carefully look them over')
    waitrt?
    bput('wear my zill', 'You slide')

    true
  end

  def get_visible_bodies
    result = []
    all_bodies = @settings.constellations
    bput('observe sky', 'The following heavenly bodies are visible:')
    until (line = get?) =~ /^Roundtime/i
      result << all_bodies.find { |body| /\b#{body['name']}\b/i =~ line && line !~ /below the horizon/ }
    end
    result.compact.select { |data| data['circle'] <= DRStats.circle }
  end

  def train_astrology
    fput('pre pg 5') unless DRSpells.active_spells['Piercing Gaze'] > 1
    fput('predict weather')
    pause 2
    waitrt?
    bput('cast', 'you ') unless DRSpells.active_spells['Piercing Gaze'] > 1

    vis_bodies = get_visible_bodies

    night = vis_bodies.find { |body| body['constellation'] }

    vis_bodies = vis_bodies.select { |data| @settings.have_telescope || !data['telescope'] }

    best_eye_data = vis_bodies.max_by { |data| [data['pools'].values.compact.size, data['circle']] }

    echo(best_eye_data) if UserVars.crossing_trainer_debug

    waitrt?

    observed = if @settings.have_telescope
                 bput('get telescope', 'you get')
                 things_to_try = @settings.constellations.select do |data|
                   data['telescope'] &&
                     data['circle'] <= DRStats.circle &&
                     data['circle'] > best_eye_data['circle'] &&
                     (night || !data['constellation']) &&
                     data['pools'].values.compact.size > best_eye_data['pools'].values.compact.size
                 end

                 things_to_try << best_eye_data

                 things_to_try.sort! { |data| data['circle'] }.reverse!

                 echo(things_to_try) if UserVars.crossing_trainer_debug

                 things_to_try.find do |data|
                   bput("center telescope on #{data['name']}", 'You put your eye')
                   result = nil
                   until ['Roundtime', 'You peer aimlessly through your telescope'].include?(result)
                     result = bput('peer telescope', 'You peer aimlessly through your telescope', 'You see nothing regarding the future', 'Roundtime')
                   end
                   result == 'Roundtime'
                 end
               else
                 until 'Roundtime' == bput("observe #{best_eye_data['name']}", 'Your search for', 'You see nothing regarding the future', 'Roundtime')
                 end
                 best_eye_data
               end
    pause 2
    waitrt?

    bput('stow telescope', 'you put') if @settings.have_telescope

    observed['pools'].each do |skill, value|
      next unless value
      bput("align #{skill}", 'You focus internally')
      waitrt?
      bput('predict future', 'roundtime')
      waitrt?
    end
    bput('predict anal', 'roundtime')
    waitrt?
  end

  def train_outfitting
    if @settings.train_workorders([]).include?('Tailoring')
      return unless money_for_training?(5000, 'Outfitting')
      wait_for_script_to_complete('workorders', ['Tailoring'])
      wait_for_script_to_complete('sell-loot')
      return
    end

    rank = DRSkill.getrank('Outfitting')
    if rank <= 25 # Tier 1  Extremely Easy
      sew(5, 'knitted socks', 'socks')
    elsif rank <= 50 # Tier 2 Very Easy
      sew(5, 'knitted mittens', 'mittens')
    elsif rank <= 100 # Tier 3  Easy
      sew(5, 'knitted hat', 'hat')
    elsif rank <= 175 # Tier 4  Simple
      sew(5, 'knitted gloves', 'gloves')
    elsif rank <= 300 # Tier 5  Basic
      sew(5, 'knitted hose', 'hose')
    elsif rank <= 425 # Tier 6  Somewhat Challenging
      sew(5, 'knitted cloak', 'cloak')
    elsif rank <= 550 # Tier 7  Challenging
      sew(5, 'knitted blanket', 'blanket')
    else # Tier 12  Extremely Difficult
      echo('*** NOT YET IMPLEMENTED ***')
    end
  end

  def train_engineering
    return unless money_for_training?(5000, 'Engineering')
    wait_for_script_to_complete('workorders', ['Shaping'])
    wait_for_script_to_complete('sell-loot')
  end

  def train_trading
    disciplines = @settings.work_order_disciplines

    unless disciplines
      beep
      echo('SELECT DISCIPLINES FOR TRADING TRAINING WITH work_order_disciplines:')
      beep
      pause 5
      return
    end

    discipline = disciplines.min_by { |s| DRSkill.getxp(@disciplines_to_skill[s]) }

    return unless money_for_training?(5000, 'Trading')
    wait_for_script_to_complete('workorders', [discipline])
    wait_for_script_to_complete('sell-loot')
  end

  # https://elanthipedia.play.net/mediawiki/index.php/Blacksmithing_Products
  def train_forging
    if @settings.train_workorders([]).include?('Blacksmithing')
      return unless money_for_training?(5000, 'Forging')
      wait_for_script_to_complete('workorders', ['Blacksmithing'])
      wait_for_script_to_complete('sell-loot')
      return
    end

    rank = DRSkill.getrank('Forging')
    if rank <= 25 # Tier 1	Extremely Easy
      smith('a shallow metal cup')
    elsif rank <= 50 # Tier 2	Very Easy
      smith('a short metal mug')
    elsif rank <= 100 # Tier 3	Easy
      smith('a back scratcher')
    elsif rank <= 175 # Tier 4	Simple
      smith('a metal ankle band')
    elsif rank <= 300 # Tier 5	Basic
      smith('a metal lockpick ring')
    elsif rank <= 425 # Tier 6	Somewhat Challenging
      smith('a metal armband')
    elsif rank <= 550 # Tier 7	Challenging
      smith('some metal clippers')
    elsif rank <= 700 # Tier 8	Complicated
      echo('*** NOT YET IMPLEMENTED ***')
      # Journeyman book: triangular wire sieve, bent <metal> scissors, knobby sewing needles, squat knitting needles, narrow <metal> awl
    elsif rank <= 850 # Tier 9	Intricate
      echo('*** NOT YET IMPLEMENTED ***')
      # Master book: beveled wood shaper, serrated hide scraper, compact <metal> awl, compact <metal> awl, round pestle
    elsif rank <= 1175 # Tier 10	Difficult
      echo('*** NOT YET IMPLEMENTED ***')
      # Master book: slender <metal> awl, serrated scissors, grooved pestle, oblong wire sieve
    elsif rank <= 1400 # Tier 11	Very Difficult
      echo('*** NOT YET IMPLEMENTED ***')
      # Master book: jagged wood shaper, thin sewing needles
    else # Tier 12	Extremely Difficult
      echo('*** NOT YET IMPLEMENTED ***')
      # Master book: trapezoidal wire sieve
    end
  end

  def money_for_training?(amount, skill)
    if ensure_copper_on_hand(amount)
      true
    else
      echo("Low on funds, removing #{skill} from training")
      @settings.crossing_training([]).delete(skill)
      false
    end
  end

  def sew(chapter, unique_name, item)
    buy_yarn

    walk_to(@settings.safe_room)
    check_listening

    wait_for_script_to_complete('sew', ['trash', 'knitting', chapter, unique_name, item])

    fput('get my wool yarn')
    dispose_trash('yarn')
  end

  def smith(full_name)
    wait_for_script_to_complete('smith', ['bronze', full_name, 'buy'])
    dispose_trash(checkright)
    dispose_trash(checkleft)
  end

  def buy_yarn
    return unless money_for_training?(700, 'Outfitting')
    walk_to 16_667
    fput('order 13')
    fput('order 13')
    fput('stow my yarn')
  end

  def stop_play
    return unless @did_play
    return if @no_instrument
    @did_play = false
    bput('stop play', 'You stop playing your song', 'In the name of', "But you're not performing")
    Flags['ct-song'] = true
  end

  def play_song?(blocking = false)
    UserVars.song = @song_list.first.first unless UserVars.song
    return if @no_instrument
    @did_play = true
    case bput("play #{UserVars.song}", 'dirtiness may affect your performance', 'slightest hint of difficulty', 'You begin a', 'You struggle to begin', 'You\'re already playing a song', 'You effortlessly begin', 'You begin some', 'You cannot play', 'Play on what instrument', 'now isn\'t the best time to be playing', 'Perhaps you should find somewhere drier before trying to play')
    when 'Play on what instrument'
      @no_instrument = true
      return false
    when 'now isn\'t the best time to be playing', 'Perhaps you should find somewhere drier before trying to play'
      return true
    when 'You cannot play'
      wait_for_script_to_complete('safe-room')
    when 'dirtiness may affect your performance'
      stop_play
      clean_zills
      return play_song?
    when 'You begin a', 'You effortlessly begin', 'You begin some'
      stop_play
      UserVars.song = @song_list[UserVars.song] || @song_list.first.first
      return play_song?
    when 'You struggle to begin'
      if UserVars.song != @song_list.first.first
        stop_play
        UserVars.song = @song_list.first.first
        return play_song?
      end
    end

    return true unless blocking

    Flags.reset('ct-song')
    pause 1 until Flags['ct-song']
    true
  end

  def clean_zills
    bput('remove my zills', 'You slide')
    bput('get my cloth', 'You get a')

    until /not in need of drying/i =~ bput('wipe my zills with my cloth', 'Roundtime', 'not in need of drying')
      pause 1
      waitrt?
      until /you wring a dry/i =~ bput('wring my cloth', 'You wring a dry', 'You wring out')
        pause 1
        waitrt?
      end
    end

    until /not in need of cleaning/i =~ bput('clean my zills with my cloth', 'Roundtime', 'not in need of cleaning')
      pause 1
      waitrt?
    end

    bput('wear my zill', 'You slide')
    bput('stow my cloth', 'You put your')
  end
end

# Call this last to avoid the need for forward declarations
$CROSSING_TRAINER = CrossingTraining.new
$CROSSING_TRAINER.main
